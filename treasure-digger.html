<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Treasure Digger Â· æŒ–å®èƒŒå•è¯å¤§å¸ˆ</title>
  <style>
    :root {
      --dirt-brown: #8B4513;
      --grass-green: #228B22;
      --treasure-gold: #FFD700;
      --treasure-silver: #C0C0C0;
      --treasure-bronze: #CD7F32;
      --treasure-diamond: #B9F2FF;
      --tool-color: #4A4A4A;
      --sky-blue: #87CEEB;
      --cloud-white: #FFFFFF;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'Georgia', 'Times New Roman', serif;
      background: linear-gradient(to bottom, var(--sky-blue) 0%, #98FB98 100%);
      min-height: 100vh;
      overflow-x: hidden;
    }
    
    /* Game Container */
    #game-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    
    /* Header */
    .game-header {
      background: linear-gradient(45deg, #8B4513, #A0522D);
      color: white;
      padding: 15px 25px;
      border-radius: 15px;
      text-align: center;
      margin-bottom: 20px;
      box-shadow: 0 8px 16px rgba(0,0,0,0.3);
    }
    
    .game-title {
      font-size: 28px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    
    /* Status Bar */
    .status-bar {
      display: flex;
      justify-content: space-between;
      background: rgba(255,255,255,0.9);
      padding: 15px 25px;
      border-radius: 10px;
      margin-bottom: 20px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: bold;
    }
    
    .status-icon {
      font-size: 20px;
    }
    
    /* Main Game Area */
    .game-area {
      display: grid;
      grid-template-columns: 1fr 300px;
      gap: 20px;
    }
    
    /* Digging Ground */
    .digging-ground {
      background: linear-gradient(to bottom, var(--grass-green) 0%, var(--grass-green) 10%, var(--dirt-brown) 10%);
      border: 3px solid #654321;
      border-radius: 15px;
      min-height: 600px;
      position: relative;
      overflow: hidden;
      box-shadow: inset 0 10px 20px rgba(0,0,0,0.3);
    }
    
    .grass-surface {
      height: 60px;
      background: linear-gradient(to bottom, var(--grass-green), #32CD32);
      position: relative;
    }
    
    .dirt-area {
      flex: 1;
      background-image: 
        radial-gradient(circle at 20% 20%, rgba(139,69,19,0.8) 2px, transparent 2px),
        radial-gradient(circle at 80% 80%, rgba(160,82,45,0.6) 1px, transparent 1px),
        radial-gradient(circle at 40% 60%, rgba(101,67,33,0.4) 1px, transparent 1px);
      background-size: 50px 50px, 30px 30px, 20px 20px;
      padding: 20px;
      position: relative;
    }
    
    /* Treasure Spots */
    .treasure-spot {
      position: absolute;
      width: 50px;
      height: 50px;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 10;
    }
    
    .treasure-spot:hover {
      transform: scale(1.1);
      filter: brightness(1.2);
    }
    
    .treasure-buried {
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      border: 3px solid rgba(255,255,255,0.5);
    }
    
    .treasure-bronze { background: linear-gradient(45deg, var(--treasure-bronze), #B87333); }
    .treasure-silver { background: linear-gradient(45deg, var(--treasure-silver), #A8A8A8); }
    .treasure-gold { background: linear-gradient(45deg, var(--treasure-gold), #B8860B); }
    .treasure-diamond { background: linear-gradient(45deg, var(--treasure-diamond), #87CEEB); }
    
    /* Tool Panel */
    .tool-panel {
      background: linear-gradient(145deg, #F4E4BC, #DDD0A7);
      border: 3px solid #8B4513;
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 8px 16px rgba(0,0,0,0.2);
    }
    
    .panel-title {
      font-size: 20px;
      font-weight: bold;
      color: #654321;
      margin-bottom: 15px;
      text-align: center;
    }
    
    .current-tool {
      background: rgba(255,255,255,0.8);
      border: 2px solid #8B4513;
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
      text-align: center;
    }
    
    .tool-icon {
      font-size: 40px;
      margin-bottom: 10px;
      display: block;
    }
    
    .tool-name {
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .tool-power {
      color: #666;
      font-size: 14px;
    }
    
    .action-buttons {
      display: grid;
      gap: 10px;
    }
    
    .action-btn {
      padding: 12px;
      border: none;
      border-radius: 10px;
      font-weight: bold;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.3s ease;
    }
    
    .shop-btn {
      background: linear-gradient(45deg, #FF6B6B, #FF8E53);
      color: white;
    }
    
    .inventory-btn {
      background: linear-gradient(45deg, #4ECDC4, #45B7B8);
      color: white;
    }
    
    .market-btn {
      background: linear-gradient(45deg, #FFA726, #FFB74D);
      color: white;
    }
    
    .cards-btn {
      background: linear-gradient(45deg, #9B59B6, #8E44AD);
      color: white;
    }
    
    .action-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.2);
    }
    
    /* Learning Modal */
    .learning-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .learning-content {
      background: linear-gradient(145deg, #3D2914, #2A1A0A);
      border: 3px solid var(--treasure-gold);
      border-radius: 20px;
      padding: 30px;
      max-width: 500px;
      text-align: center;
      color: white;
    }
    
    .treasure-display {
      margin: 20px 0;
    }
    
    .treasure-word {
      font-size: 48px;
      font-weight: bold;
      color: var(--treasure-gold);
      margin-bottom: 10px;
    }
    
    .treasure-phonetic {
      font-size: 20px;
      color: var(--treasure-silver);
      margin-bottom: 15px;
      font-style: italic;
    }
    
    .treasure-meaning {
      font-size: 16px;
      line-height: 1.5;
      margin-bottom: 20px;
    }
    
    .pronunciation-section {
      margin: 20px 0;
    }
    
    .speak-instruction {
      margin-bottom: 15px;
      font-size: 18px;
    }
    
    .speak-btn {
      background: linear-gradient(145deg, var(--treasure-gold), #FFED4A);
      color: #2D1B0A;
      border: none;
      padding: 15px 30px;
      border-radius: 15px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      margin: 10px;
    }
    
    .listen-btn {
      background: linear-gradient(145deg, #9C88FF, #6C5CE7);
      color: white;
      border: none;
      padding: 12px 25px;
      border-radius: 10px;
      font-size: 16px;
      cursor: pointer;
      margin: 5px;
    }
    
    .manual-input-section {
      margin-top: 20px;
      display: flex;
      gap: 10px;
      justify-content: center;
    }
    
    .word-input {
      padding: 12px;
      border: 2px solid #8B4513;
      border-radius: 8px;
      font-size: 16px;
      background: rgba(255,255,255,0.9);
    }
    
    .submit-btn {
      background: linear-gradient(145deg, #28A745, #20C997);
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      cursor: pointer;
    }
    
    .feedback {
      margin-top: 20px;
      font-size: 16px;
      font-weight: bold;
      min-height: 30px;
    }
    
    .feedback.success {
      color: var(--treasure-gold);
    }
    
    .feedback.error {
      color: #FF6B6B;
    }
    
    /* Shop Modal */
    .shop-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      backdrop-filter: blur(5px);
    }
    
    .shop-content {
      background: linear-gradient(145deg, #8B4513, #A0522D);
      border: 3px solid var(--treasure-gold);
      border-radius: 20px;
      width: min(90vw, 600px);
      max-height: 80vh;
      overflow-y: auto;
      color: white;
    }
    
    .shop-header {
      background: linear-gradient(90deg, var(--treasure-gold), #FFED4A, var(--treasure-gold));
      color: #2D1B0A;
      padding: 20px;
      text-align: center;
      font-size: 24px;
      font-weight: bold;
      border-radius: 17px 17px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .shop-close {
      background: none;
      border: none;
      font-size: 30px;
      cursor: pointer;
      color: #2D1B0A;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .shop-close:hover {
      background: rgba(45,27,10,0.2);
    }
    
    .shop-info {
      padding: 20px;
      background: rgba(255,255,255,0.1);
      margin: 20px;
      border-radius: 10px;
      text-align: center;
    }
    
    .current-coins {
      font-size: 18px;
      font-weight: bold;
      color: var(--treasure-gold);
    }
    
    .shop-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      padding: 20px;
    }
    
    .tool-card {
      background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
      border: 2px solid rgba(255,215,0,0.3);
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      transition: all 0.3s ease;
    }
    
    .tool-card:hover {
      border-color: var(--treasure-gold);
      background: linear-gradient(145deg, rgba(255,255,255,0.15), rgba(255,255,255,0.1));
      transform: translateY(-5px);
    }
    
    .tool-card.owned {
      border-color: var(--treasure-silver);
      background: linear-gradient(145deg, rgba(192,192,192,0.2), rgba(192,192,192,0.1));
    }
    
    .tool-card.equipped {
      border-color: var(--treasure-gold);
      background: linear-gradient(145deg, rgba(255,215,0,0.2), rgba(255,215,0,0.1));
      box-shadow: 0 0 20px rgba(255,215,0,0.3);
    }
    
    .tool-card-icon {
      font-size: 48px;
      margin-bottom: 10px;
      display: block;
    }
    
    .tool-card-name {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 8px;
      color: var(--treasure-gold);
    }
    
    .tool-card-description {
      font-size: 14px;
      margin-bottom: 10px;
      opacity: 0.9;
      line-height: 1.4;
    }
    
    .tool-card-power {
      background: rgba(255,255,255,0.2);
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 12px;
      margin-bottom: 15px;
      display: inline-block;
    }
    
    .tool-card-price {
      font-size: 16px;
      font-weight: bold;
      color: var(--treasure-gold);
      margin-bottom: 15px;
    }
    
    .tool-buy-btn, .tool-equip-btn {
      background: linear-gradient(45deg, #28A745, #20C997);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      width: 100%;
    }
    
    .tool-buy-btn:hover, .tool-equip-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    }
    
    .tool-buy-btn:disabled {
      background: #666;
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    .tool-equip-btn {
      background: linear-gradient(45deg, #FF6B6B, #FF8E53);
    }
    
    .tool-equipped {
      background: linear-gradient(45deg, var(--treasure-gold), #FFED4A);
      color: #2D1B0A;
    }
    
    @media (max-width: 768px) {
      .shop-grid {
        grid-template-columns: 1fr;
        padding: 15px;
      }
      
      .tool-card {
        padding: 15px;
      }
    }
    
    /* Inventory Modal */
    .inventory-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      backdrop-filter: blur(5px);
    }
    
    .inventory-content {
      background: linear-gradient(145deg, #4ECDC4, #45B7B8);
      border: 3px solid var(--treasure-gold);
      border-radius: 20px;
      width: min(90vw, 700px);
      max-height: 80vh;
      overflow-y: auto;
      color: white;
    }
    
    .inventory-header {
      background: linear-gradient(90deg, var(--treasure-gold), #FFED4A, var(--treasure-gold));
      color: #2D1B0A;
      padding: 20px;
      text-align: center;
      font-size: 24px;
      font-weight: bold;
      border-radius: 17px 17px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .inventory-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
      padding: 20px;
    }
    
    .treasure-item {
      background: linear-gradient(145deg, rgba(255,255,255,0.15), rgba(255,255,255,0.1));
      border: 2px solid rgba(255,215,0,0.3);
      border-radius: 15px;
      padding: 15px;
      text-align: center;
      transition: all 0.3s ease;
    }
    
    .treasure-item:hover {
      border-color: var(--treasure-gold);
      background: linear-gradient(145deg, rgba(255,255,255,0.2), rgba(255,255,255,0.15));
      transform: translateY(-3px);
    }
    
    .treasure-item-icon {
      font-size: 40px;
      margin-bottom: 10px;
      display: block;
    }
    
    .treasure-item-name {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 8px;
      color: var(--treasure-gold);
    }
    
    .treasure-item-desc {
      font-size: 12px;
      margin-bottom: 10px;
      opacity: 0.9;
      line-height: 1.3;
    }
    
    .treasure-item-value {
      background: rgba(255,255,255,0.2);
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 12px;
      margin-bottom: 10px;
      display: inline-block;
    }
    
    /* Market Modal */
    .market-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      backdrop-filter: blur(5px);
    }
    
    /* Cards Modal */
    .cards-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      backdrop-filter: blur(5px);
    }
    
    .cards-content {
      background: linear-gradient(145deg, #9B59B6, #8E44AD);
      border: 3px solid var(--treasure-gold);
      border-radius: 20px;
      width: min(95vw, 900px);
      max-height: 90vh;
      overflow-y: auto;
      color: white;
    }
    
    .cards-header {
      background: linear-gradient(90deg, var(--treasure-gold), #FFED4A, var(--treasure-gold));
      color: #2D1B0A;
      padding: 20px;
      text-align: center;
      font-size: 24px;
      font-weight: bold;
      border-radius: 17px 17px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .cards-info {
      padding: 20px;
      background: rgba(255,255,255,0.1);
      margin: 20px;
      border-radius: 10px;
      text-align: center;
    }
    
    .cards-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 15px;
      padding: 20px;
    }
    
    .equipped-cards-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      min-height: 120px;
    }
    
    .skill-card {
      background: linear-gradient(145deg, rgba(255,255,255,0.15), rgba(255,255,255,0.05));
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      transition: all 0.3s ease;
      position: relative;
    }
    
    .skill-card:hover {
      background: linear-gradient(145deg, rgba(255,255,255,0.2), rgba(255,255,255,0.1));
      transform: translateY(-5px);
    }
    
    .skill-card.owned {
      border-color: var(--treasure-silver);
    }
    
    .skill-card.equipped {
      border-color: var(--treasure-gold);
      background: linear-gradient(145deg, rgba(255,215,0,0.2), rgba(255,215,0,0.1));
      box-shadow: 0 0 20px rgba(255,215,0,0.3);
    }
    
    .skill-card.common {
      border-color: #888888;
    }
    
    .skill-card.rare {
      border-color: #3498db;
      box-shadow: 0 0 15px rgba(52,152,219,0.3);
    }
    
    .skill-card.epic {
      border-color: #9b59b6;
      box-shadow: 0 0 15px rgba(155,89,182,0.3);
    }
    
    .skill-card-icon {
      font-size: 40px;
      margin-bottom: 10px;
      display: block;
    }
    
    .skill-card-name {
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 8px;
      color: var(--treasure-gold);
    }
    
    .skill-card-description {
      font-size: 13px;
      margin-bottom: 10px;
      opacity: 0.9;
      line-height: 1.4;
    }
    
    .skill-card-cooldown {
      background: rgba(255,255,255,0.2);
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 11px;
      margin-bottom: 10px;
      display: inline-block;
    }
    
    .skill-card-price {
      font-size: 14px;
      font-weight: bold;
      color: var(--treasure-gold);
      margin-bottom: 10px;
    }
    
    .skill-card-btn {
      background: linear-gradient(45deg, #28A745, #20C997);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      width: 100%;
      font-size: 12px;
    }
    
    .skill-card-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    
    .skill-card-btn:disabled {
      background: #666;
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    .skill-card-btn.equip {
      background: linear-gradient(45deg, #FF6B6B, #FF8E53);
    }
    
    .skill-card-btn.unequip {
      background: linear-gradient(45deg, #FFA726, #FFB74D);
    }
    
    .skill-card-btn.use {
      background: linear-gradient(45deg, #9B59B6, #8E44AD);
    }
    
    .skill-card-btn.on-cooldown {
      background: linear-gradient(45deg, #666, #555);
      cursor: not-allowed;
    }
    
    .empty-slot {
      background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
      border: 2px dashed rgba(255,255,255,0.3);
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100px;
      opacity: 0.7;
    }
    
    .cooldown-overlay {
      position: absolute;
      top: 5px;
      right: 5px;
      background: rgba(255,0,0,0.8);
      color: white;
      border-radius: 50%;
      width: 25px;
      height: 25px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: bold;
    }
    
    .market-content {
      background: linear-gradient(145deg, #FFA726, #FFB74D);
      border: 3px solid var(--treasure-gold);
      border-radius: 20px;
      width: min(90vw, 700px);
      max-height: 80vh;
      overflow-y: auto;
      color: white;
    }
    
    .market-header {
      background: linear-gradient(90deg, var(--treasure-gold), #FFED4A, var(--treasure-gold));
      color: #2D1B0A;
      padding: 20px;
      text-align: center;
      font-size: 24px;
      font-weight: bold;
      border-radius: 17px 17px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .market-info {
      padding: 20px;
      background: rgba(255,255,255,0.1);
      margin: 20px;
      border-radius: 10px;
      text-align: center;
    }
    
    .sell-btn {
      background: linear-gradient(45deg, #FF6B6B, #FF8E53);
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      width: 100%;
    }
    
    .sell-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    }
    
    .sell-btn:disabled {
      background: #666;
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    /* Player and Enemy System */
    .player-character {
      position: absolute;
      width: 40px;
      height: 40px;
      font-size: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
      transition: all 0.3s ease;
      cursor: pointer;
      border-radius: 50%;
      background: rgba(255,255,255,0.2);
      border: 2px solid rgba(255,215,0,0.5);
    }
    
    .player-character:hover {
      transform: scale(1.1);
      background: rgba(255,215,0,0.3);
    }
    
    .enemy-character {
      position: absolute;
      width: 35px;
      height: 35px;
      font-size: 25px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 45;
      transition: all 0.3s ease;
      cursor: pointer;
      border-radius: 50%;
      background: rgba(255,0,0,0.2);
      border: 2px solid rgba(255,0,0,0.5);
    }
    
    .enemy-character:hover {
      transform: scale(1.1);
      background: rgba(255,0,0,0.4);
    }
    
    .player-hp-bar, .enemy-hp-bar {
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      width: 50px;
      height: 6px;
      background: rgba(0,0,0,0.5);
      border-radius: 3px;
    }
    
    .hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #FF6B6B, #4ECDC4);
      border-radius: 3px;
      transition: width 0.3s ease;
    }
    
    .enemy-hp {
      background: linear-gradient(90deg, #FF4444, #FF6666);
    }
    
    /* Battle Modal */
    .battle-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 3000;
      backdrop-filter: blur(5px);
    }
    
    .battle-content {
      background: linear-gradient(145deg, #2C3E50, #34495E);
      border: 3px solid var(--treasure-gold);
      border-radius: 20px;
      width: min(90vw, 800px);
      max-height: 90vh;
      overflow-y: auto;
      color: white;
    }
    
    .battle-header {
      background: linear-gradient(90deg, var(--treasure-gold), #FFED4A, var(--treasure-gold));
      color: #2D1B0A;
      padding: 20px;
      text-align: center;
      font-size: 24px;
      font-weight: bold;
      border-radius: 17px 17px 0 0;
    }
    
    .battle-arena {
      display: flex;
      justify-content: space-around;
      align-items: center;
      padding: 40px 20px;
      gap: 20px;
    }
    
    .battle-player, .battle-enemy {
      text-align: center;
      flex: 1;
    }
    
    .battle-character {
      font-size: 60px;
      margin-bottom: 10px;
      animation: battleIdle 2s infinite ease-in-out;
    }
    
    .battle-name {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
      color: var(--treasure-gold);
    }
    
    .battle-hp-bar {
      width: 150px;
      height: 10px;
      background: rgba(0,0,0,0.5);
      border-radius: 5px;
      margin: 10px auto;
      overflow: hidden;
    }
    
    .battle-stats {
      font-size: 12px;
      opacity: 0.8;
      margin-top: 5px;
    }
    
    .battle-vs {
      font-size: 24px;
      font-weight: bold;
      color: var(--treasure-gold);
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      animation: battleVs 1.5s infinite ease-in-out;
    }
    
    .battle-actions {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      padding: 20px;
      background: rgba(255,255,255,0.1);
    }
    
    .battle-btn {
      padding: 15px 20px;
      border: none;
      border-radius: 10px;
      font-weight: bold;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.3s ease;
      color: white;
    }
    
    .attack-btn {
      background: linear-gradient(45deg, #E74C3C, #C0392B);
    }
    
    .defend-btn {
      background: linear-gradient(45deg, #3498DB, #2980B9);
    }
    
    .skill-btn {
      background: linear-gradient(45deg, #9B59B6, #8E44AD);
    }
    
    .flee-btn {
      background: linear-gradient(45deg, #95A5A6, #7F8C8D);
    }
    
    .battle-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    }
    
    .battle-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .battle-log {
      max-height: 150px;
      overflow-y: auto;
      padding: 20px;
      background: rgba(0,0,0,0.2);
      border-radius: 0 0 17px 17px;
    }
    
    .battle-message {
      margin: 5px 0;
      font-size: 14px;
      line-height: 1.4;
    }
    
    .battle-message.player-action {
      color: #4ECDC4;
    }
    
    .battle-message.enemy-action {
      color: #FF6B6B;
    }
    
    .battle-message.system {
      color: var(--treasure-gold);
      font-style: italic;
    }
    
    @keyframes battleIdle {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
    }
    
    @keyframes battleVs {
      0%, 100% { transform: scale(1); opacity: 0.8; }
      50% { transform: scale(1.1); opacity: 1; }
    }
    
    @keyframes battleAttack {
      0% { transform: translateX(0); }
      25% { transform: translateX(20px); }
      50% { transform: translateX(0); }
      75% { transform: translateX(-10px); }
      100% { transform: translateX(0); }
    }
    
    @keyframes battleDamage {
      0%, 100% { transform: translateX(0); filter: brightness(1); }
      25% { transform: translateX(-10px); filter: brightness(1.5); }
      50% { transform: translateX(10px); filter: brightness(0.5); }
      75% { transform: translateX(-5px); filter: brightness(1.2); }
    }
    
    .empty-inventory, .empty-market {
      text-align: center;
      padding: 40px 20px;
      opacity: 0.7;
    }
    
    .empty-inventory-icon, .empty-market-icon {
      font-size: 60px;
      margin-bottom: 20px;
      display: block;
    }
    
    /* Progress Indicators */
    .digging-progress {
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 12px;
      z-index: 20;
    }
    
    .hit-effect {
      position: absolute;
      font-size: 30px;
      z-index: 30;
      pointer-events: none;
      animation: hitEffect 1s ease-out forwards;
    }
    
    @keyframes hitEffect {
      0% {
        opacity: 1;
        transform: scale(0.5) translateY(0);
      }
      100% {
        opacity: 0;
        transform: scale(1.5) translateY(-50px);
      }
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .game-area {
        grid-template-columns: 1fr;
      }
      
      .status-bar {
        flex-wrap: wrap;
        gap: 10px;
      }
      
      .treasure-spot {
        width: 40px;
        height: 40px;
      }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <!-- Game Header -->
    <div class="game-header">
      <div class="game-title">ğŸº æŒ–å®èƒŒå•è¯å¤§å¸ˆ â›ï¸</div>
    </div>
    
    <!-- Status Bar -->
    <div class="status-bar">
      <div class="status-item">
        <span class="status-icon">ğŸ’°</span>
        <span>é‡‘å¸: <strong id="coins">500</strong></span>
      </div>
      <div class="status-item">
        <span class="status-icon">ğŸ’</span>
        <span>å®ç‰©: <strong id="treasures-found">0</strong></span>
      </div>
      <div class="status-item">
        <span class="status-icon">âš¡</span>
        <span>ç­‰çº§: <strong id="player-level">1</strong></span>
      </div>
      <div class="status-item">
        <span class="status-icon">â¤ï¸</span>
        <span>ç”Ÿå‘½: <strong id="player-hp">100/100</strong></span>
      </div>
      <div class="status-item">
        <span class="status-icon">ğŸ¯</span>
        <span>å•å…ƒ: <strong id="current-unit">æ··åˆæ¨¡å¼</strong></span>
      </div>
    </div>
    
    <!-- Main Game Area -->
    <div class="game-area">
      <!-- Digging Ground -->
      <div class="digging-ground">
        <div class="grass-surface"></div>
        <div class="dirt-area" id="dirt-area">
          <!-- Player character -->
          <div class="player-character" id="player-character">ğŸš€</div>
          <!-- Treasure spots and enemies will be generated here -->
        </div>
      </div>
      
      <!-- Tool Panel -->
      <div class="tool-panel">
        <div class="panel-title">ğŸ› ï¸ æŒ–æ˜å·¥å…·</div>
        
        <div class="current-tool">
          <span class="tool-icon" id="current-tool-icon">ğŸ”¨</span>
          <div class="tool-name" id="current-tool-name">åŸºç¡€é“é”¤</div>
          <div class="tool-power" id="current-tool-power">æŒ–æ˜åŠ›: 1 (éœ€è¦3-5æ¬¡)</div>
        </div>
        
        <div class="action-buttons">
          <button class="action-btn shop-btn" id="shop-btn">
            ğŸª å·¥å…·å•†åº—
          </button>
          <button class="action-btn inventory-btn" id="inventory-btn">
            ğŸ’ èƒŒåŒ…åº“å­˜
          </button>
          <button class="action-btn market-btn" id="market-btn">
            ğŸ›ï¸ å®ç‰©å¸‚åœº
          </button>
          <button class="action-btn cards-btn" id="cards-btn">
            ğŸƒ æŠ€èƒ½å¡ç‰Œ
          </button>
        </div>
        
        <div class="game-controls" style="
          background: rgba(255,255,255,0.8);
          border: 1px solid #8B4513;
          border-radius: 8px;
          padding: 10px;
          margin-top: 15px;
          font-size: 12px;
          color: #654321;
        ">
          <div style="font-weight: bold; margin-bottom: 5px;">ğŸ® æ¸¸æˆæ§åˆ¶</div>
          <div>ğŸ¹ WASDï¼šç§»åŠ¨è§’è‰²</div>
          <div>â£ ç©ºæ ¼ï¼šä¸é™„è¿‘ç‰©ä½“äº¤äº’</div>
          <div>ğŸ‘ï¸ é•è‰²é«˜äº®ï¼šå¯äº¤äº’åŒºåŸŸ</div>
        </div>
        
        <div class="auxiliary-tools" id="auxiliary-tools">
          <div class="panel-title" style="font-size: 16px; margin: 15px 0 10px 0;">ğŸ”§ è¾…åŠ©é“å…·</div>
          <!-- Auxiliary tools will be rendered here -->
        </div>
      </div>
    </div>
  </div>
  
  <!-- Learning Modal -->
  <div class="learning-modal" id="learning-modal">
    <div class="learning-content">
      <div class="treasure-display">
        <div class="treasure-word" id="modal-word">treasure</div>
        <div class="treasure-phonetic" id="modal-phonetic">/ËˆtrÉ›Ê’É™r/</div>
        <div class="treasure-meaning" id="modal-meaning">ä¸€ä¸ªçè´µçš„å®è—ï¼Œç­‰å¾…å‹‡æ•¢çš„æ¢é™©è€…å‘ç°</div>
      </div>
      
      <div class="pronunciation-section">
        <div class="speak-instruction">ğŸ™ï¸ å¤§å£°è¯´å‡ºè¿™ä¸ªå•è¯æ¥è·å¾—å®è—ï¼</div>
        <button class="listen-btn" id="listen-btn">ğŸ”Š å¬å‘éŸ³</button>
        <button class="speak-btn" id="speak-btn">å¼€å§‹è¯­éŸ³è¯†åˆ«</button>
        
        <div class="manual-input-section">
          <input type="text" class="word-input" id="word-input" placeholder="æˆ–è€…æ‰‹åŠ¨è¾“å…¥å•è¯">
          <button class="submit-btn" id="submit-word-btn">æäº¤</button>
        </div>
      </div>
      
      <div class="feedback" id="learning-feedback">å‡†å¤‡å¥½äº†å—ï¼Ÿ</div>
    </div>
  </div>

  <!-- Shop Modal -->
  <div class="shop-modal" id="shop-modal">
    <div class="shop-content">
      <div class="shop-header">
        <span>ğŸª æŒ–æ˜å·¥å…·å•†åº—</span>
        <button class="shop-close" id="shop-close">Ã—</button>
      </div>
      
      <div class="shop-info">
        <div class="current-coins">ğŸ’° å½“å‰é‡‘å¸: <span id="shop-coins">500</span></div>
        <div style="margin-top: 10px; font-size: 14px; opacity: 0.8;">
          è´­ä¹°æ›´å¼ºå¤§çš„å·¥å…·ï¼Œæé«˜æŒ–æ˜æ•ˆç‡ï¼
        </div>
      </div>
      
      <div class="shop-grid" id="shop-grid">
        <!-- Tool cards will be generated here -->
      </div>
    </div>
  </div>

  <!-- Inventory Modal -->
  <div class="inventory-modal" id="inventory-modal">
    <div class="inventory-content">
      <div class="inventory-header">
        <span>ğŸ’ å®ç‰©èƒŒåŒ…</span>
        <button class="shop-close" id="inventory-close">Ã—</button>
      </div>
      
      <div class="inventory-grid" id="inventory-grid">
        <!-- Inventory items will be generated here -->
      </div>
    </div>
  </div>

  <!-- Market Modal -->
  <div class="market-modal" id="market-modal">
    <div class="market-content">
      <div class="market-header">
        <span>ğŸ›ï¸ å®ç‰©å¸‚åœº</span>
        <button class="shop-close" id="market-close">Ã—</button>
      </div>
      
      <div class="market-info">
        <div class="current-coins">ğŸ’° å½“å‰é‡‘å¸: <span id="market-coins">500</span></div>
        <div style="margin-top: 10px; font-size: 14px; opacity: 0.8;">
          åœ¨è¿™é‡Œå‡ºå”®ä½ çš„å®ç‰©è·å¾—é‡‘å¸ï¼ä»·æ ¼ä¼šæ ¹æ®å¸‚åœºè¡Œæƒ…æµ®åŠ¨ã€‚
        </div>
      </div>
      
      <div class="inventory-grid" id="market-grid">
        <!-- Market items will be generated here -->
      </div>
    </div>
  </div>

  <!-- Skill Cards Modal -->
  <div class="cards-modal" id="cards-modal">
    <div class="cards-content">
      <div class="cards-header">
        <span>ğŸƒ æŠ€èƒ½å¡ç‰Œ</span>
        <button class="shop-close" id="cards-close">Ã—</button>
      </div>
      
      <div class="cards-info">
        <div class="current-coins">ğŸ’° å½“å‰é‡‘å¸: <span id="cards-coins">500</span></div>
        <div style="margin-top: 10px; font-size: 14px; opacity: 0.8;">
          è´­ä¹°å¹¶è£…å¤‡æŠ€èƒ½å¡ç‰Œï¼Œè·å¾—ç‰¹æ®Šèƒ½åŠ›ï¼æœ€å¤šåŒæ—¶è£…å¤‡3å¼ å¡ç‰Œã€‚
        </div>
      </div>
      
      <!-- Equipped Cards Section -->
      <div id="equipped-cards-section" style="margin: 20px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 10px;">
        <h3 style="text-align: center; margin-bottom: 15px; color: #FFD700;">âš”ï¸ å·²è£…å¤‡å¡ç‰Œ (3/3)</h3>
        <div class="equipped-cards-grid" id="equipped-cards-grid">
          <!-- Equipped cards will be rendered here -->
        </div>
      </div>
      
      <!-- Available Cards Section -->
      <div class="cards-grid" id="cards-grid">
        <!-- Available cards will be generated here -->
      </div>
    </div>
  </div>

  <!-- Battle Modal -->
  <div class="battle-modal" id="battle-modal">
    <div class="battle-content">
      <div class="battle-header">
        <span>âš”ï¸ æˆ˜æ–—ä¸­</span>
      </div>
      
      <div class="battle-arena">
        <div class="battle-player">
          <div class="battle-character">ğŸš€</div>
          <div class="battle-name">ç©å®¶</div>
          <div class="battle-hp-bar">
            <div class="hp-fill" id="battle-player-hp" style="width: 100%;"></div>
          </div>
          <div class="battle-stats" id="battle-player-stats">HP: 100/100 | ATK: 10 | DEF: 5</div>
        </div>
        
        <div class="battle-vs">ï¸ VS</div>
        
        <div class="battle-enemy">
          <div class="battle-character" id="battle-enemy-char">ğŸ‘¾</div>
          <div class="battle-name" id="battle-enemy-name">æ€ªç‰©</div>
          <div class="battle-hp-bar">
            <div class="hp-fill enemy-hp" id="battle-enemy-hp" style="width: 100%;"></div>
          </div>
          <div class="battle-stats" id="battle-enemy-stats">HP: 50/50 | ATK: 8</div>
        </div>
      </div>
      
      <div class="battle-actions" id="battle-actions">
        <button class="battle-btn attack-btn" onclick="playerAttack()">âš”ï¸ æ”»å‡»</button>
        <button class="battle-btn defend-btn" onclick="playerDefend()">ğŸ›¡ï¸ é˜²å¾¡</button>
        <button class="battle-btn skill-btn" onclick="useSkillInBattle()">âœ¨ æŠ€èƒ½</button>
        <button class="battle-btn flee-btn" onclick="fleeBattle()">ğŸƒ é€ƒè·‘</button>
      </div>
      
      <div class="battle-log" id="battle-log">
        <div class="battle-message">é‡åˆ°äº†é‡ç”Ÿæ€ªç‰©ï¼å‡†å¤‡æˆ˜æ–—ï¼</div>
      </div>
    </div>
  </div>

  <script>
    // Game State
    const gameState = {
      coins: 500,
      treasuresFound: 0,
      playerLevel: 1,
      currentUnit: null,
      currentTool: {
        id: 'basic_hammer',
        name: 'åŸºç¡€é“é”¤',
        icon: 'ğŸ”¨',
        power: 1,
        description: 'æŒ–æ˜åŠ›: 1 (éœ€è¦3-5æ¬¡)'
      },
      inventory: [],
      treasureSpots: [],
      currentTreasure: null,
      recognizing: false,
      ownedTools: ['basic_hammer'], // æ‹¥æœ‰çš„å·¥å…·åˆ—è¡¨
      equippedTool: 'basic_hammer', // å½“å‰è£…å¤‡çš„å·¥å…·
      auxiliaryTools: [], // è¾…åŠ©é“å…·åˆ—è¡¨
      consumableItems: { energy_drink: 0 }, // æ¶ˆè€—å“æ•°é‡
      activeEffects: [], // å½“å‰æ¿€æ´»çš„æ•ˆæœ
      skillCards: [], // æ‹¥æœ‰çš„æŠ€èƒ½å¡ç‰Œ
      equippedCards: [], // è£…å¤‡çš„æŠ€èƒ½å¡ç‰Œ (æœ€å¤š3å¼ )
      cardCooldowns: {}, // å¡ç‰Œå†·å´æ—¶é—´
      // Battle system
      player: {
        x: 250,
        y: 200,
        hp: 100,
        maxHp: 100,
        level: 1,
        exp: 0,
        expToNext: 100,
        attack: 10,
        defense: 5
      },
      enemies: [],
      inBattle: false,
      currentEnemy: null,
      battleTurn: 'player' // 'player' or 'enemy'
    };

    // Audio System
    let audioContext;
    let audioInitialized = false;

    function initializeAudio() {
      if (!audioInitialized) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        audioInitialized = true;
      }
    }
    
    function playSound(type, frequency = 440, duration = 200) {
      initializeAudio();
      if (!audioContext) return;
      
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      switch(type) {
        case 'dig':
          // æŒ–æ˜éŸ³æ•ˆ - æ’å‡»å£°
          oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.1);
          oscillator.type = 'sawtooth';
          duration = 150;
          break;
        case 'treasure_found':
          // å‘ç°å®ç‰©éŸ³æ•ˆ - ç¥ç§˜éŸ³è°ƒ
          oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.3);
          oscillator.type = 'sine';
          duration = 500;
          break;
        case 'success':
          // æˆåŠŸéŸ³æ•ˆ - ä¸Šå‡éŸ³è°ƒ
          oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + duration / 1000);
          oscillator.type = 'sine';
          break;
        case 'error':
          // é”™è¯¯éŸ³æ•ˆ - ä¸‹é™éŸ³è°ƒ
          oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + duration / 1000);
          oscillator.type = 'sawtooth';
          break;
        case 'coin':
          // é‡‘å¸éŸ³æ•ˆ - æ¸…è„†éŸ³è°ƒ
          oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.1);
          oscillator.type = 'square';
          duration = 150;
          break;
        case 'click':
          // ç‚¹å‡»éŸ³æ•ˆ
          oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
          oscillator.type = 'triangle';
          duration = 100;
          break;
        case 'level_up':
          // å‡çº§éŸ³æ•ˆ
          playLevelUpSound();
          return;
        case 'magic':
          // é­”æ³•éŸ³æ•ˆ - ç¥å¥‡çš„éŸ³è°ƒ
          oscillator.frequency.setValueAtTime(523, audioContext.currentTime); // C5
          oscillator.frequency.exponentialRampToValueAtTime(784, audioContext.currentTime + 0.2); // G5
          oscillator.frequency.exponentialRampToValueAtTime(1047, audioContext.currentTime + 0.4); // C6
          oscillator.type = 'sine';
          duration = 600;
          break;
      }
      
      gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + duration / 1000);
    }
    
    function playLevelUpSound() {
      // å‡çº§éŸ³æ•ˆ - ä¸‰ä¸ªéŸ³ç¬¦ç»„æˆçš„æ—‹å¾‹
      const notes = [523, 659, 784]; // C5, E5, G5
      notes.forEach((freq, i) => {
        setTimeout(() => playSound('success', freq, 300), i * 200);
      });
    }

    function playDiggingSequence(toolPower) {
      // æ ¹æ®å·¥å…·ç­‰çº§æ’­æ”¾ä¸åŒçš„æŒ–æ˜éŸ³æ•ˆ
      if (toolPower >= 5) {
        playSound('magic'); // é­”æ³•å·¥å…·
      } else if (toolPower >= 3) {
        playSound('dig', 100, 200); // é«˜çº§å·¥å…·
      } else {
        playSound('dig', 150, 150); // æ™®é€šå·¥å…·
      }
    }

    // Tools Configuration
    const TOOLS = {
      basic_hammer: { 
        name: 'åŸºç¡€é“é”¤', 
        icon: 'ğŸ”¨', 
        power: 1, 
        cost: 0, 
        description: 'æœ€åŸºç¡€çš„æŒ–æ˜å·¥å…·ï¼Œè™½ç„¶æ•ˆç‡ä¸é«˜ï¼Œä½†æ˜¯å…è´¹ä½¿ç”¨ã€‚',
        powerDesc: 'æŒ–æ˜åŠ›: 1 (éœ€è¦6-10æ¬¡)'
      },
      iron_pickaxe: { 
        name: 'é“åˆ¶é•å­', 
        icon: 'â›ï¸', 
        power: 2, 
        cost: 200, 
        description: 'é“åŒ ç²¾å¿ƒæ‰“é€ çš„é•å­ï¼ŒæŒ–æ˜æ•ˆç‡ç¿»å€ï¼Œæ˜¯å†’é™©è€…çš„å¥½ä¼™ä¼´ã€‚',
        powerDesc: 'æŒ–æ˜åŠ›: 2 (éœ€è¦4-6æ¬¡)'
      },
      steel_drill: { 
        name: 'é’¢é“é’»å¤´', 
        icon: 'ğŸ”©', 
        power: 3, 
        cost: 500, 
        description: 'å·¥ä¸šçº§é’»å¤´ï¼Œæœºæ¢°åŠ›é‡è®©æŒ–æ˜å˜å¾—è½»æ¾ï¼Œé€‚åˆä¸“ä¸šæŒ–å®è€…ã€‚',
        powerDesc: 'æŒ–æ˜åŠ›: 3 (éœ€è¦2-4æ¬¡)'
      },
      diamond_excavator: { 
        name: 'é’»çŸ³æŒ–æ˜æœº', 
        icon: 'ğŸ’', 
        power: 5, 
        cost: 1000, 
        description: 'é¡¶çº§ç§‘æŠ€äº§ç‰©ï¼Œé’»çŸ³ç¡¬åº¦è®©ä»»ä½•å®ç‰©éƒ½æ— æ³•æŠµæŒ¡ï¼Œé«˜æ•ˆæŒ–æ˜ï¼',
        powerDesc: 'æŒ–æ˜åŠ›: 5 (éœ€è¦1-2æ¬¡)'
      },
      magic_wand: { 
        name: 'é­”æ³•æ³•æ–', 
        icon: 'ğŸª„', 
        power: 10, 
        cost: 2000, 
        description: 'ä¼ è¯´ä¸­çš„ç¥å™¨ï¼Œè•´å«å¤è€é­”æ³•ï¼Œèƒ½å¤Ÿç¬é—´æå–ä»»ä½•åŸ‹è—çš„å®ç‰©ï¼',
        powerDesc: 'é­”æ³•æŒ–æ˜ (ç¬é—´å®Œæˆ!)'
      },
      // Auxiliary Tools
      treasure_detector: {
        name: 'å®ç‰©æ¢æµ‹å™¨',
        icon: 'ğŸ“¡',
        power: 0,
        cost: 300,
        description: 'é«˜ç§‘æŠ€æ¢æµ‹è®¾å¤‡ï¼Œèƒ½å¤Ÿæ˜¾ç¤ºé™„è¿‘å®ç‰©çš„å¤§è‡´ä»·å€¼ï¼Œè®©æŒ–æ˜æ›´æœ‰é’ˆå¯¹æ€§ã€‚',
        powerDesc: 'è¾…åŠ©å·¥å…· (æ˜¾ç¤ºå®ç‰©ä»·å€¼)',
        type: 'auxiliary'
      },
      market_insider: {
        name: 'å¸‚åœºå†…å¹•æ¶ˆæ¯',
        icon: 'ğŸ“Š',
        power: 0,
        cost: 150,
        description: 'è·å¾—å¸‚åœºå†…éƒ¨æ¶ˆæ¯ï¼Œè®©ä½ åœ¨å‡ºå”®å®ç‰©æ—¶è·å¾—æ›´å¥½çš„ä»·æ ¼ã€‚',
        powerDesc: 'è¾…åŠ©é“å…· (æé«˜å”®ä»·10-30%)',
        type: 'auxiliary'
      },
      lucky_charm: {
        name: 'å¹¸è¿æŠ¤ç¬¦',
        icon: 'ğŸ€',
        power: 0,
        cost: 800,
        description: 'ç¥ç§˜çš„å¹¸è¿æŠ¤ç¬¦ï¼Œå¢åŠ å‘ç°é«˜ä»·å€¼å®ç‰©çš„æ¦‚ç‡ã€‚',
        powerDesc: 'å¹¸è¿åŠ æˆ (ç¨€æœ‰å®ç‰©+25%)',
        type: 'auxiliary'
      },
      energy_drink: {
        name: 'èƒ½é‡é¥®æ–™',
        icon: 'âš¡',
        power: 0,
        cost: 50,
        description: 'æç¥é¥®æ–™ï¼Œä¸´æ—¶æé«˜æŒ–æ˜æ•ˆç‡ã€‚æ¯æ¬¡ä½¿ç”¨åæ¶ˆè€—ã€‚',
        powerDesc: 'ä¸´æ—¶é“å…· (ä¸‹æ¬¡æŒ–æ˜åŠ›+1)',
        type: 'consumable'
      }
    };

    // Skill Cards Configuration
    const SKILL_CARDS = {
      // æ”»å‡»ç±»å¡ç‰Œ
      power_strike: {
        id: 'power_strike',
        name: 'åŠ›é‡æ‰“å‡»',
        icon: 'ğŸ’ª',
        rarity: 'common',
        cost: 100,
        cooldown: 3, // å†·å´å›åˆæ•°
        description: 'ä¸‹ä¸€æ¬¡æŒ–æ˜çš„åŠ›é‡ç¿»å€',
        effect: {
          type: 'next_dig_power',
          multiplier: 2
        }
      },
      lightning_dig: {
        id: 'lightning_dig',
        name: 'é—ªç”µæŒ–æ˜',
        icon: 'âš¡',
        rarity: 'rare',
        cost: 200,
        cooldown: 5,
        description: 'ç«‹å³å®Œæˆå½“å‰å®ç‰©çš„æŒ–æ˜',
        effect: {
          type: 'instant_complete'
        }
      },
      treasure_magnet: {
        id: 'treasure_magnet',
        name: 'å®ç‰©ç£é“',
        icon: 'ğŸ§²',
        rarity: 'epic',
        cost: 300,
        cooldown: 8,
        description: 'å¸å¼•ä¸€ä¸ªæ–°çš„å®ç‰©åˆ°éšæœºä½ç½®',
        effect: {
          type: 'spawn_treasure'
        }
      },
      
      // å¢ç›Šç±»å¡ç‰Œ
      golden_touch: {
        id: 'golden_touch',
        name: 'ç‚¹é‡‘æœ¯',
        icon: 'âœ¨',
        rarity: 'rare',
        cost: 150,
        cooldown: 6,
        description: 'æ¥ä¸‹æ¥3ä¸ªå®ç‰©çš„ä»·å€¼+50%',
        effect: {
          type: 'gold_boost',
          multiplier: 1.5,
          duration: 3
        }
      },
      lucky_charm: {
        id: 'lucky_charm',
        name: 'å¹¸è¿ç¬¦å’’',
        icon: 'ğŸ€',
        rarity: 'common',
        cost: 80,
        cooldown: 4,
        description: 'å¢åŠ å‘ç°ç¨€æœ‰å®ç‰©çš„æ¦‚ç‡',
        effect: {
          type: 'luck_boost',
          duration: 5
        }
      },
      energy_surge: {
        id: 'energy_surge',
        name: 'èƒ½é‡æ¶ŒåŠ¨',
        icon: 'ğŸ”¥',
        rarity: 'epic',
        cost: 250,
        cooldown: 10,
        description: 'é‡ç½®æ‰€æœ‰å…¶ä»–å¡ç‰Œçš„å†·å´æ—¶é—´',
        effect: {
          type: 'reset_cooldowns'
        }
      },

      // é˜²å¾¡/å·¥å…·ç±»å¡ç‰Œ
      tool_repair: {
        id: 'tool_repair',
        name: 'å·¥å…·ç»´ä¿®',
        icon: 'ğŸ”§',
        rarity: 'common',
        cost: 60,
        cooldown: 2,
        description: 'ä¸´æ—¶æå‡å·¥å…·æ•ˆç‡20%',
        effect: {
          type: 'tool_boost',
          multiplier: 1.2,
          duration: 3
        }
      },
      treasure_vision: {
        id: 'treasure_vision',
        name: 'å®ç‰©é€è§†',
        icon: 'ğŸ‘ï¸',
        rarity: 'rare',
        cost: 180,
        cooldown: 7,
        description: 'æ˜¾ç¤ºæ‰€æœ‰åŸ‹è—å®ç‰©çš„ä½ç½®',
        effect: {
          type: 'reveal_treasures',
          duration: 10
        }
      }
    };

    // Card rarity colors and drop rates
    const CARD_RARITY = {
      common: { color: '#888888', dropRate: 0.6 },
      rare: { color: '#3498db', dropRate: 0.3 },
      epic: { color: '#9b59b6', dropRate: 0.1 }
    };

    // Enemy Types
    const ENEMY_TYPES = {
      goblin: {
        name: 'å“¥å¸ƒæ—',
        icon: 'ğŸ‘º',
        hp: 40,
        attack: 8,
        defense: 2,
        exp: 25,
        gold: 15,
        spawnChance: 0.4
      },
      orc: {
        name: 'å…½äºº',
        icon: 'ğŸ‘¹',
        hp: 60,
        attack: 12,
        defense: 4,
        exp: 40,
        gold: 25,
        spawnChance: 0.3
      },
      skeleton: {
        name: 'éª·é«…æˆ˜å£«',
        icon: 'ğŸ’€',
        hp: 50,
        attack: 10,
        defense: 3,
        exp: 30,
        gold: 20,
        spawnChance: 0.2
      },
      dragon: {
        name: 'å°é¾™',
        icon: 'ğŸ‰',
        hp: 100,
        attack: 18,
        defense: 6,
        exp: 75,
        gold: 50,
        spawnChance: 0.1
      }
    };

    // Treasure Types
    const TREASURE_TYPES = ['bronze', 'silver', 'gold', 'diamond'];
    const TREASURE_VALUES = {
      bronze: { min: 20, max: 50, hits: [6,7,8] },
      silver: { min: 60, max: 100, hits: [8,9,10] },
      gold: { min: 150, max: 250, hits: [10,12,14] },
      diamond: { min: 300, max: 500, hits: [12,15,18] }
    };

    // Unit Treasures (reuse from previous code)
    const UNIT_TREASURES = {
      unit1: {
        name: "Unit 1 - åˆæ¬¡ç›¸é‡",
        icon: "ğŸ‘‹",
        words: [
          { name: 'name', ipa: '/neÉªm/', desc: 'è®°å½•èº«ä»½çš„ç¥ç§˜ç¬¦æ–‡', value: 20, icon: 'ğŸ“›' },
          { name: 'hello', ipa: '/hÉ™ËˆloÊŠ/', desc: 'å¼€å¯å‹è°Šå¤§é—¨çš„é­”æ³•å’’è¯­', value: 20, icon: 'ğŸ‘‹' },
          { name: 'good', ipa: '/É¡ÊŠd/', desc: 'è•´å«å–„è‰¯åŠ›é‡çš„å¤è€è¯æ±‡', value: 25, icon: 'âœ¨' },
          { name: 'nice', ipa: '/naÉªs/', desc: 'å¸¦æ¥æ„‰æ‚¦çš„æ¸©æš–å®çŸ³', value: 25, icon: 'ğŸ˜Š' },
          { name: 'meet', ipa: '/miËt/', desc: 'è¿æ¥å¿ƒçµçš„æ¡¥æ¢', value: 25, icon: 'ğŸ¤' },
          { name: 'thanks', ipa: '/Î¸Ã¦Å‹ks/', desc: 'æ„Ÿæ©ä¹‹å¿ƒçš„ç¾å¥½å›å“', value: 35, icon: 'ğŸ™' },
        ]
      },
      unit2: {
        name: "Unit 2 - å®¶åº­æˆå‘˜",
        icon: "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦",
        words: [
          { name: 'family', ipa: '/ËˆfÃ¦mÉ™li/', desc: 'è¡€è„‰ç›¸è¿çš„æ¸©æš–æ¸¯æ¹¾', value: 35, icon: 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦' },
          { name: 'father', ipa: '/ËˆfÉ‘ËÃ°É™r/', desc: 'å¦‚å±±èˆ¬åšå®çš„å®ˆæŠ¤è€…', value: 35, icon: 'ğŸ‘¨' },
          { name: 'mother', ipa: '/ËˆmÊŒÃ°É™r/', desc: 'å¦‚æµ·èˆ¬æ·±æƒ…çš„å‘µæŠ¤è€…', value: 35, icon: 'ğŸ‘©' },
          { name: 'sister', ipa: '/ËˆsÉªstÉ™r/', desc: 'å¿ƒçµç›¸é€šçš„ç«ç‘°èŠ±', value: 35, icon: 'ğŸ‘­' },
          { name: 'brother', ipa: '/ËˆbrÊŒÃ°É™r/', desc: 'å¹¶è‚©ä½œæˆ˜çš„æˆ˜å‹', value: 40, icon: 'ğŸ‘¬' },
          { name: 'friend', ipa: '/frend/', desc: 'æ‚£éš¾ä¸å…±çš„çè´µå®è—', value: 35, icon: 'ğŸ‘«' }
        ]
      }
      // Add more units as needed
    };

    // DOM Elements
    const elements = {
      coins: document.getElementById('coins'),
      treasuresFound: document.getElementById('treasures-found'),
      playerLevel: document.getElementById('player-level'),
      currentUnit: document.getElementById('current-unit'),
      currentToolIcon: document.getElementById('current-tool-icon'),
      currentToolName: document.getElementById('current-tool-name'),
      currentToolPower: document.getElementById('current-tool-power'),
      dirtArea: document.getElementById('dirt-area'),
      learningModal: document.getElementById('learning-modal'),
      modalWord: document.getElementById('modal-word'),
      modalPhonetic: document.getElementById('modal-phonetic'),
      modalMeaning: document.getElementById('modal-meaning'),
      listenBtn: document.getElementById('listen-btn'),
      speakBtn: document.getElementById('speak-btn'),
      wordInput: document.getElementById('word-input'),
      submitWordBtn: document.getElementById('submit-word-btn'),
      learningFeedback: document.getElementById('learning-feedback'),
      shopBtn: document.getElementById('shop-btn'),
      inventoryBtn: document.getElementById('inventory-btn'),
      marketBtn: document.getElementById('market-btn'),
      // Shop elements
      shopModal: document.getElementById('shop-modal'),
      shopClose: document.getElementById('shop-close'),
      shopCoins: document.getElementById('shop-coins'),
      shopGrid: document.getElementById('shop-grid'),
      // Inventory elements
      inventoryModal: document.getElementById('inventory-modal'),
      inventoryClose: document.getElementById('inventory-close'),
      inventoryGrid: document.getElementById('inventory-grid'),
      // Market elements
      marketModal: document.getElementById('market-modal'),
      marketClose: document.getElementById('market-close'),
      marketCoins: document.getElementById('market-coins'),
      marketGrid: document.getElementById('market-grid'),
      // Cards elements
      cardsBtn: document.getElementById('cards-btn'),
      cardsModal: document.getElementById('cards-modal'),
      cardsClose: document.getElementById('cards-close'),
      cardsCoins: document.getElementById('cards-coins'),
      cardsGrid: document.getElementById('cards-grid'),
      equippedCardsGrid: document.getElementById('equipped-cards-grid'),
      // Battle elements
      playerHp: document.getElementById('player-hp'),
      playerCharacter: document.getElementById('player-character'),
      battleModal: document.getElementById('battle-modal'),
      battleActions: document.getElementById('battle-actions'),
      battleLog: document.getElementById('battle-log'),
      battlePlayerHp: document.getElementById('battle-player-hp'),
      battleEnemyHp: document.getElementById('battle-enemy-hp'),
      battlePlayerStats: document.getElementById('battle-player-stats'),
      battleEnemyStats: document.getElementById('battle-enemy-stats'),
      battleEnemyChar: document.getElementById('battle-enemy-char'),
      battleEnemyName: document.getElementById('battle-enemy-name')
    };

    // Initialize Game
    function initGame() {
      // Ensure player character exists and is positioned correctly
      const dirtArea = elements.dirtArea;
      let playerElement = dirtArea.querySelector('#player-character');
      if (!playerElement) {
        playerElement = document.createElement('div');
        playerElement.className = 'player-character';
        playerElement.id = 'player-character';
        playerElement.textContent = 'ğŸš€';
        dirtArea.appendChild(playerElement);
      }
      
      // Set initial position
      playerElement.style.left = gameState.player.x + 'px';
      playerElement.style.top = gameState.player.y + 'px';
      
      generateTreasureSpots();
      updateUI();
      setupEventListeners();
    }

    // Generate random treasure spots
    function generateTreasureSpots() {
      const dirtArea = elements.dirtArea;
      const areaWidth = 500; // Approximate width
      const areaHeight = 500; // Approximate height
      
      // Clear existing spots but preserve player
      gameState.treasureSpots = [];
      gameState.enemies = [];
      
      // Clear all elements except player
      const existingElements = dirtArea.querySelectorAll('.treasure-spot, .enemy-character');
      existingElements.forEach(element => {
        if (element.parentNode) {
          element.parentNode.removeChild(element);
        }
      });
      
      // Ensure player character exists
      let playerElement = dirtArea.querySelector('#player-character');
      if (!playerElement) {
        playerElement = document.createElement('div');
        playerElement.className = 'player-character';
        playerElement.id = 'player-character';
        playerElement.textContent = 'ğŸš€';
        playerElement.style.left = gameState.player.x + 'px';
        playerElement.style.top = gameState.player.y + 'px';
        dirtArea.appendChild(playerElement);
      }
      
      // Generate 12-15 treasure spots
      const numSpots = 12 + Math.floor(Math.random() * 4);
      
      for (let i = 0; i < numSpots; i++) {
        const spot = enhancedCreateTreasureSpot(i, areaWidth, areaHeight);
        gameState.treasureSpots.push(spot);
        
        const spotElement = document.createElement('div');
        spotElement.className = `treasure-spot treasure-${spot.type}`;
        spotElement.style.left = spot.x + 'px';
        spotElement.style.top = spot.y + 'px';
        spotElement.dataset.spotId = i;
        
        const buriedDiv = document.createElement('div');
        buriedDiv.className = 'treasure-buried';
        buriedDiv.textContent = spot.word.icon;
        
        // Show value if treasure detector is owned
        if (spot.showValue) {
          const valueIndicator = document.createElement('div');
          valueIndicator.className = 'treasure-value-indicator';
          valueIndicator.textContent = `ğŸ’°${spot.value}`;
          valueIndicator.style.cssText = `
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,215,0,0.9);
            color: black;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
          `;
          spotElement.appendChild(valueIndicator);
        }
        
        spotElement.appendChild(buriedDiv);
        dirtArea.appendChild(spotElement);
        
        spotElement.addEventListener('click', () => {
          // Always allow click, but check distance inside digTreasure
          digTreasure(i);
        });
      }
      
      // Generate enemies
      generateEnemies(areaWidth, areaHeight);
    }
    
    // Generate enemies
    function generateEnemies(areaWidth, areaHeight) {
      const numEnemies = 3 + Math.floor(Math.random() * 3); // 3-5 enemies
      
      for (let i = 0; i < numEnemies; i++) {
        const enemy = createEnemy(i, areaWidth, areaHeight);
        gameState.enemies.push(enemy);
        
        const enemyElement = document.createElement('div');
        enemyElement.className = 'enemy-character';
        enemyElement.style.left = enemy.x + 'px';
        enemyElement.style.top = enemy.y + 'px';
        enemyElement.dataset.enemyId = i;
        enemyElement.textContent = enemy.icon;
        
        // Add HP bar
        const hpBar = document.createElement('div');
        hpBar.className = 'enemy-hp-bar';
        const hpFill = document.createElement('div');
        hpFill.className = 'hp-fill';
        hpFill.style.width = '100%';
        hpBar.appendChild(hpFill);
        enemyElement.appendChild(hpBar);
        
        elements.dirtArea.appendChild(enemyElement);
        
        enemyElement.addEventListener('click', () => {
          const distance = getDistance(
            gameState.player.x + 20, gameState.player.y + 20,
            enemy.x + 17, enemy.y + 17
          );
          if (distance < 50) {
            startBattle(enemy);
          }
        });
      }
    }
    
    // Create individual enemy
    function createEnemy(id, maxWidth, maxHeight) {
      const enemyTypes = Object.keys(ENEMY_TYPES);
      const randomType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
      const enemyTemplate = ENEMY_TYPES[randomType];
      
      // Avoid spawning too close to player
      let x, y, distance;
      do {
        x = Math.random() * (maxWidth - 60);
        y = Math.random() * (maxHeight - 60);
        distance = getDistance(gameState.player.x, gameState.player.y, x, y);
      } while (distance < 80); // Minimum distance from player
      
      return {
        id,
        type: randomType,
        name: enemyTemplate.name,
        icon: enemyTemplate.icon,
        hp: enemyTemplate.hp,
        maxHp: enemyTemplate.hp,
        attack: enemyTemplate.attack,
        defense: enemyTemplate.defense,
        exp: enemyTemplate.exp,
        gold: enemyTemplate.gold,
        x,
        y,
        defeated: false
      };
    }

    // Check if current level is complete
    function checkLevelComplete() {
      const remaining = gameState.treasureSpots.filter(spot => !spot.discovered).length;
      
      if (remaining === 0) {
        showLevelCompleteModal();
      }
    }

    // Show level complete celebration
    function showLevelCompleteModal() {
      playSound('level_up');
      
      const encouragements = [
        "ğŸŠ å¤ªæ£’äº†ï¼ä½ æ˜¯çœŸæ­£çš„æŒ–å®å¤§å¸ˆï¼",
        "ğŸ† å®Œç¾ï¼ä½ çš„æŒ–æ˜æŠ€å·§ä»¤äººæƒŠå¹ï¼",
        "â­ æƒŠäººçš„æˆå°±ï¼ç»§ç»­ä¿æŒä¸‹å»ï¼",
        "ğŸŒŸ ä½ çš„å­¦ä¹ çƒ­æƒ…ä»¤äººæ•¬ä½©ï¼",
        "ğŸ¯ ä¼˜ç§€ï¼ä½ å·²ç»æŒæ¡äº†æ‰€æœ‰å®è—ï¼",
        "ğŸ’« å¤ªå‰å®³äº†ï¼æŒ–å®èƒŒå•è¯åŒä¸°æ”¶ï¼"
      ];
      
      const bonus = Math.floor(gameState.treasuresFound * 10 + Math.random() * 100);
      gameState.coins += bonus;
      
      const encouragement = encouragements[Math.floor(Math.random() * encouragements.length)];
      
      setTimeout(() => {
        alert(`${encouragement}\n\nğŸ å®Œæˆå¥–åŠ±: +${bonus} é‡‘å¸\nğŸ’° å½“å‰æ€»é‡‘å¸: ${gameState.coins}\n\nå‡†å¤‡å¼€å§‹ä¸‹ä¸€è½®æŒ–å®å†’é™©å—ï¼Ÿ`);
        
        setTimeout(() => {
          startNextRound();
        }, 1000);
      }, 500);
    }

    // Start next round
    function startNextRound() {
      gameState.playerLevel++;
      updateUI();
      generateTreasureSpots();
      
      // Show new round notification
      setTimeout(() => {
        const newRoundMessages = [
          "ğŸ—ºï¸ å‘ç°äº†æ–°çš„å®è—åœ°ç‚¹ï¼",
          "â›ï¸ æ–°ä¸€è½®çš„æŒ–å®å†’é™©å¼€å§‹äº†ï¼",
          "ğŸº æ›´å¤šç¥ç§˜å®è—ç­‰å¾…å‘ç°ï¼",
          "ğŸ’ å‡†å¤‡å¥½ä½ çš„å·¥å…·ï¼Œæ–°çš„æŒ‘æˆ˜æ¥äº†ï¼",
          "ğŸŒ æ¢ç´¢æ–°çš„æŒ–æ˜åŒºåŸŸï¼"
        ];
        
        const message = newRoundMessages[Math.floor(Math.random() * newRoundMessages.length)];
        alert(`${message}\n\nğŸ†™ ç­‰çº§æå‡è‡³ ${gameState.playerLevel} çº§\nğŸ¯ ç»§ç»­ä½ çš„å•è¯å­¦ä¹ ä¹‹æ—…ï¼`);
      }, 500);
    }

    // Create individual treasure spot
    function createTreasureSpot(id, maxWidth, maxHeight) {
      const words = getAllWords();
      const word = words[Math.floor(Math.random() * words.length)];
      
      // Determine treasure type based on word value
      let type = 'bronze';
      if (word.value >= 300) type = 'diamond';
      else if (word.value >= 150) type = 'gold';
      else if (word.value >= 60) type = 'silver';
      
      const treasureConfig = TREASURE_VALUES[type];
      const hitsRequired = treasureConfig.hits[Math.floor(Math.random() * treasureConfig.hits.length)];
      
      return {
        id,
        word,
        type,
        value: word.value,
        hitsRequired,
        hitsRemaining: hitsRequired,
        x: Math.random() * (maxWidth - 60),
        y: Math.random() * (maxHeight - 60),
        discovered: false
      };
    }

    // Get all words from units
    function getAllWords() {
      const words = [];
      Object.values(UNIT_TREASURES).forEach(unit => {
        words.push(...unit.words);
      });
      return words;
    }

    // Enhanced dig treasure with auxiliary effects and card effects
    function digTreasure(spotId) {
      const spot = gameState.treasureSpots[spotId];
      if (!spot || spot.discovered) return;
      
      // Check proximity
      const distance = getDistance(
        gameState.player.x + 20, gameState.player.y + 20,
        spot.x + 25, spot.y + 25
      );
      
      if (distance >= 60) {
        playSound('click');
        // Show temporary message
        const messageElement = document.createElement('div');
        messageElement.textContent = 'ğŸš¶ é è¿‘ä¸€äº›å†æŒ–æ˜';
        messageElement.style.cssText = `
          position: fixed;
          top: 20%;
          left: 50%;
          transform: translateX(-50%);
          background: linear-gradient(45deg, #FF6B6B, #FF8E53);
          color: white;
          padding: 8px 15px;
          border-radius: 20px;
          font-weight: bold;
          font-size: 14px;
          z-index: 9999;
          pointer-events: none;
          box-shadow: 0 4px 8px rgba(0,0,0,0.3);
          animation: slideDown 0.3s ease;
        `;
        
        // Add CSS animation
        if (!document.querySelector('#proximityMessageStyle')) {
          const style = document.createElement('style');
          style.id = 'proximityMessageStyle';
          style.textContent = `
            @keyframes slideDown {
              0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
              100% { opacity: 1; transform: translateX(-50%) translateY(0); }
            }
          `;
          document.head.appendChild(style);
        }
        
        document.body.appendChild(messageElement);
        setTimeout(() => {
          if (messageElement.parentNode) {
            messageElement.parentNode.removeChild(messageElement);
          }
        }, 1500);
        return; // Too far away
      }
      
      const tool = gameState.currentTool;
      let damage = tool.power;
      
      // Apply energy drink effect
      const energyEffect = gameState.activeEffects.find(e => e.type === 'energy_boost');
      if (energyEffect) {
        damage += 1;
        energyEffect.remaining--;
        if (energyEffect.remaining <= 0) {
          gameState.activeEffects = gameState.activeEffects.filter(e => e !== energyEffect);
        }
        createHitEffect(spotId, '+1âš¡', 'energy-boost');
      }
      
      // Apply power boost card effect
      const powerBoost = gameState.activeEffects.find(e => e.type === 'power_boost');
      if (powerBoost) {
        damage *= powerBoost.multiplier;
        powerBoost.remaining--;
        if (powerBoost.remaining <= 0) {
          gameState.activeEffects = gameState.activeEffects.filter(e => e !== powerBoost);
        }
        createHitEffect(spotId, `x${powerBoost.multiplier}ğŸ’ª`, 'power-boost');
      }
      
      // Apply tool efficiency boost
      const toolBoost = gameState.activeEffects.find(e => e.type === 'tool_efficiency');
      if (toolBoost) {
        damage = Math.ceil(damage * toolBoost.multiplier);
        toolBoost.remaining--;
        if (toolBoost.remaining <= 0) {
          gameState.activeEffects = gameState.activeEffects.filter(e => e !== toolBoost);
        }
        createHitEffect(spotId, '+ğŸ”§', 'tool-boost');
      }
      
      damage = Math.min(damage, spot.hitsRemaining);
      spot.hitsRemaining -= damage;
      
      // Play digging sound effect
      playDiggingSequence(tool.power);
      
      // Visual feedback
      createHitEffect(spotId, damage);
      updateProgressIndicator(spotId, spot);
      
      if (spot.hitsRemaining <= 0) {
        // Treasure discovered!
        spot.discovered = true;
        
        // Reduce card cooldowns
        reduceCardCooldowns();
        
        // Play treasure found sound
        setTimeout(() => {
          playSound('treasure_found');
        }, 300);
        
        showLearningModal(spot);
      }
    }

    // Enhanced create hit effect
    function createHitEffect(spotId, damage, effectType = 'normal') {
      const spotElement = document.querySelector(`[data-spot-id="${spotId}"]`);
      const effect = document.createElement('div');
      effect.className = 'hit-effect';
      
      if (effectType === 'energy-boost') {
        effect.textContent = damage;
        effect.style.color = '#FFD700';
        effect.style.fontSize = '18px';
      } else if (effectType === 'power-boost') {
        effect.textContent = damage;
        effect.style.color = '#FF6B35';
        effect.style.fontSize = '20px';
        effect.style.fontWeight = 'bold';
      } else if (effectType === 'tool-boost') {
        effect.textContent = damage;
        effect.style.color = '#4ECDC4';
        effect.style.fontSize = '16px';
      } else {
        effect.textContent = '-' + damage;
      }
      
      effect.style.left = '50%';
      effect.style.top = '0';
      
      spotElement.appendChild(effect);
      
      setTimeout(() => {
        if (effect.parentNode) {
          effect.parentNode.removeChild(effect);
        }
      }, 1000);
    }

    // Update progress indicator
    function updateProgressIndicator(spotId, spot) {
      const spotElement = document.querySelector(`[data-spot-id="${spotId}"]`);
      let indicator = spotElement.querySelector('.digging-progress');
      
      if (!indicator) {
        indicator = document.createElement('div');
        indicator.className = 'digging-progress';
        spotElement.appendChild(indicator);
      }
      
      indicator.textContent = `${spot.hitsRemaining}/${spot.hitsRequired}`;
      
      if (spot.hitsRemaining <= 0) {
        setTimeout(() => {
          indicator.style.display = 'none';
        }, 500);
      }
    }

    // Show learning modal
    function showLearningModal(spot) {
      gameState.currentTreasure = spot;
      
      elements.modalWord.textContent = spot.word.name;
      elements.modalPhonetic.textContent = spot.word.ipa;
      elements.modalMeaning.textContent = spot.word.desc;
      elements.learningFeedback.textContent = 'å‡†å¤‡å¥½äº†å—ï¼Ÿ';
      elements.learningFeedback.className = 'feedback';
      
      elements.learningModal.style.display = 'flex';
    }

    // Hide learning modal
    function hideLearningModal() {
      elements.learningModal.style.display = 'none';
      if (gameState.currentTreasure) {
        removeTreasureSpot(gameState.currentTreasure.id);
        gameState.currentTreasure = null;
      }
    }

    // Remove treasure spot from view
    function removeTreasureSpot(spotId) {
      const spotElement = document.querySelector(`[data-spot-id="${spotId}"]`);
      if (spotElement) {
        spotElement.style.animation = 'treasureCollected 0.5s ease-out forwards';
        setTimeout(() => {
          if (spotElement.parentNode) {
            spotElement.parentNode.removeChild(spotElement);
          }
        }, 500);
      }
    }

    // Handle correct answer
    function handleCorrectAnswer() {
      const spot = gameState.currentTreasure;
      if (!spot) return;
      
      let goldValue = spot.value;
      
      // Apply gold multiplier card effect
      const goldBoost = gameState.activeEffects.find(e => e.type === 'gold_multiplier');
      if (goldBoost) {
        goldValue = Math.floor(goldValue * goldBoost.multiplier);
        goldBoost.remaining--;
        if (goldBoost.remaining <= 0) {
          gameState.activeEffects = gameState.activeEffects.filter(e => e !== goldBoost);
        }
      }
      
      gameState.coins += goldValue;
      gameState.treasuresFound++;
      gameState.inventory.push(spot.word);
      
      // Play success and coin sounds
      playSound('success');
      setTimeout(() => playSound('coin'), 300);
      
      const bonusText = goldValue > spot.value ? ` (ç‚¹é‡‘æœ¯åŠ æˆ!)` : '';
      elements.learningFeedback.textContent = `ğŸ‰ æ­å–œï¼è·å¾—å®è—"${spot.word.name}"ï¼+${goldValue}é‡‘å¸${bonusText}`;
      elements.learningFeedback.className = 'feedback success';
      
      updateUI();
      
      setTimeout(() => {
        hideLearningModal();
        checkLevelComplete();
      }, 2000);
    }

    // Update UI
    function updateUI() {
      elements.coins.textContent = gameState.coins;
      elements.treasuresFound.textContent = gameState.treasuresFound;
      elements.playerLevel.textContent = gameState.player.level;
      elements.playerHp.textContent = `${gameState.player.hp}/${gameState.player.maxHp}`;
      
      // Update current tool display
      const currentTool = TOOLS[gameState.equippedTool];
      gameState.currentTool = currentTool;
      elements.currentToolIcon.textContent = currentTool.icon;
      elements.currentToolName.textContent = currentTool.name;
      elements.currentToolPower.textContent = currentTool.powerDesc;
      
      // Update auxiliary tools display
      renderAuxiliaryTools();
      
      // Update player character position
      let playerElement = elements.playerCharacter || document.getElementById('player-character');
      if (playerElement) {
        playerElement.style.left = gameState.player.x + 'px';
        playerElement.style.top = gameState.player.y + 'px';
      } else {
        // Recreate player if missing
        const dirtArea = elements.dirtArea;
        if (dirtArea) {
          playerElement = document.createElement('div');
          playerElement.className = 'player-character';
          playerElement.id = 'player-character';
          playerElement.textContent = 'ğŸš€';
          playerElement.style.left = gameState.player.x + 'px';
          playerElement.style.top = gameState.player.y + 'px';
          dirtArea.appendChild(playerElement);
          // Update the reference
          elements.playerCharacter = playerElement;
        }
      }
    }

    // Render auxiliary tools panel
    function renderAuxiliaryTools() {
      const auxiliaryContainer = document.getElementById('auxiliary-tools');
      if (!auxiliaryContainer) return;
      
      let toolsHTML = '<div class="panel-title" style="font-size: 16px; margin: 15px 0 10px 0;">ğŸ”§ è¾…åŠ©é“å…·</div>';
      
      // Show owned auxiliary tools
      gameState.auxiliaryTools.forEach(toolId => {
        const tool = TOOLS[toolId];
        if (tool) {
          let statusText = 'âœ… å·²æ¿€æ´»';
          let buttonStyle = 'background: linear-gradient(45deg, #28A745, #20C997); opacity: 0.7;';
          
          toolsHTML += `
            <div class="auxiliary-tool-item" style="
              background: rgba(255,255,255,0.8);
              border: 1px solid #8B4513;
              border-radius: 8px;
              padding: 8px;
              margin-bottom: 8px;
              display: flex;
              align-items: center;
              justify-content: space-between;
            ">
              <div style="display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 18px;">${tool.icon}</span>
                <div>
                  <div style="font-size: 12px; font-weight: bold; color: #654321;">${tool.name}</div>
                  <div style="font-size: 10px; color: #666; opacity: 0.8;">${statusText}</div>
                </div>
              </div>
            </div>
          `;
        }
      });
      
      // Show consumable items
      Object.entries(gameState.consumableItems).forEach(([itemId, count]) => {
        if (count > 0) {
          const item = TOOLS[itemId];
          if (item) {
            toolsHTML += `
              <div class="auxiliary-tool-item" style="
                background: rgba(255,255,255,0.8);
                border: 1px solid #8B4513;
                border-radius: 8px;
                padding: 8px;
                margin-bottom: 8px;
                display: flex;
                align-items: center;
                justify-content: space-between;
              ">
                <div style="display: flex; align-items: center; gap: 8px;">
                  <span style="font-size: 18px;">${item.icon}</span>
                  <div>
                    <div style="font-size: 12px; font-weight: bold; color: #654321;">${item.name}</div>
                    <div style="font-size: 10px; color: #666; opacity: 0.8;">æ‹¥æœ‰: ${count} ä¸ª</div>
                  </div>
                </div>
                <button style="
                  background: linear-gradient(45deg, #FF6B35, #F7931E);
                  color: white;
                  border: none;
                  border-radius: 5px;
                  padding: 4px 8px;
                  font-size: 10px;
                  cursor: pointer;
                  font-weight: bold;
                " onclick="useConsumable('${itemId}')">ä½¿ç”¨</button>
              </div>
            `;
          }
        }
      });
      
      // Show active effects
      if (gameState.activeEffects.length > 0) {
        toolsHTML += '<div style="font-size: 14px; font-weight: bold; color: #FF6B35; margin: 10px 0 5px 0;">âœ¨ æ¿€æ´»æ•ˆæœ</div>';
        gameState.activeEffects.forEach(effect => {
          if (effect.type === 'energy_boost') {
            toolsHTML += `
              <div style="
                background: linear-gradient(45deg, #FFD700, #FFA500);
                color: #2D1B0A;
                border-radius: 8px;
                padding: 6px;
                margin-bottom: 5px;
                font-size: 11px;
                font-weight: bold;
                text-align: center;
              ">
                âš¡ èƒ½é‡å¢å¼º (å‰©ä½™${effect.remaining}æ¬¡)
              </div>
            `;
          }
        });
      }
      
      // If no auxiliary tools owned, show message
      if (gameState.auxiliaryTools.length === 0 && Object.values(gameState.consumableItems).every(count => count === 0)) {
        toolsHTML += `
          <div style="
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 12px;
            opacity: 0.7;
          ">
            ğŸ› ï¸ æš‚æ— è¾…åŠ©é“å…·<br>
            åœ¨å•†åº—ä¸­è´­ä¹°å§ï¼
          </div>
        `;
      }
      
      auxiliaryContainer.innerHTML = toolsHTML;
    }

    // Generic consumable use function
    function useConsumable(itemId) {
      if (itemId === 'energy_drink') {
        useEnergyDrink();
      }
      // Add more consumable types here in the future
    }

    // Shop Functions
    function openShop() {
      elements.shopModal.style.display = 'flex';
      elements.shopCoins.textContent = gameState.coins;
      renderShopItems();
    }

    function closeShop() {
      elements.shopModal.style.display = 'none';
    }

    function renderShopItems() {
      const shopHTML = Object.entries(TOOLS).map(([toolId, tool]) => {
        if (tool.type === 'auxiliary') {
          const isOwned = gameState.auxiliaryTools.includes(toolId);
          const canAfford = gameState.coins >= tool.cost;
          
          let cardClass = 'tool-card';
          if (isOwned) cardClass += ' owned';
          
          let buttonHTML = '';
          if (!isOwned) {
            buttonHTML = `
              <div class="tool-card-price">ğŸ’° ${tool.cost} é‡‘å¸</div>
              <button class="tool-buy-btn" ${!canAfford ? 'disabled' : ''} onclick="buyAuxiliaryTool('${toolId}')">
                ${canAfford ? 'è´­ä¹°' : 'é‡‘å¸ä¸è¶³'}
              </button>
            `;
          } else {
            buttonHTML = `
              <div class="tool-card-price">âœ… å·²æ‹¥æœ‰</div>
              <button class="tool-equipped">è¾…åŠ©å·¥å…·</button>
            `;
          }
          
          return `
            <div class="${cardClass}">
              <span class="tool-card-icon">${tool.icon}</span>
              <div class="tool-card-name">${tool.name}</div>
              <div class="tool-card-description">${tool.description}</div>
              <div class="tool-card-power">${tool.powerDesc}</div>
              ${buttonHTML}
            </div>
          `;
        } else if (tool.type === 'consumable') {
          const quantity = gameState.consumableItems[toolId] || 0;
          const canAfford = gameState.coins >= tool.cost;
          
          return `
            <div class="tool-card">
              <span class="tool-card-icon">${tool.icon}</span>
              <div class="tool-card-name">${tool.name}</div>
              <div class="tool-card-description">${tool.description}</div>
              <div class="tool-card-power">${tool.powerDesc}</div>
              <div class="tool-card-price">ğŸ’° ${tool.cost} é‡‘å¸ | æ‹¥æœ‰: ${quantity}</div>
              <button class="tool-buy-btn" ${!canAfford ? 'disabled' : ''} onclick="buyConsumable('${toolId}')">
                ${canAfford ? 'è´­ä¹°' : 'é‡‘å¸ä¸è¶³'}
              </button>
            </div>
          `;
        } else {
          const isOwned = gameState.ownedTools.includes(toolId);
          const isEquipped = gameState.equippedTool === toolId;
          const canAfford = gameState.coins >= tool.cost;
          
          let cardClass = 'tool-card';
          if (isOwned) cardClass += ' owned';
          if (isEquipped) cardClass += ' equipped';
          
          let buttonHTML = '';
          if (!isOwned && tool.cost > 0) {
            buttonHTML = `
              <div class="tool-card-price">ğŸ’° ${tool.cost} é‡‘å¸</div>
              <button class="tool-buy-btn" ${!canAfford ? 'disabled' : ''} onclick="buyTool('${toolId}')">
                ${canAfford ? 'è´­ä¹°' : 'é‡‘å¸ä¸è¶³'}
              </button>
            `;
          } else if (isOwned && !isEquipped) {
            buttonHTML = `
              <div class="tool-card-price">âœ… å·²æ‹¥æœ‰</div>
              <button class="tool-equip-btn" onclick="equipTool('${toolId}')">è£…å¤‡</button>
            `;
          } else if (isEquipped) {
            buttonHTML = `
              <div class="tool-card-price">âœ… å·²æ‹¥æœ‰</div>
              <button class="tool-equipped">å½“å‰è£…å¤‡</button>
            `;
          } else {
            buttonHTML = `
              <div class="tool-card-price">ğŸ†“ å…è´¹</div>
              <button class="tool-equip-btn" onclick="equipTool('${toolId}')">è£…å¤‡</button>
            `;
          }
          
          return `
            <div class="${cardClass}">
              <span class="tool-card-icon">${tool.icon}</span>
              <div class="tool-card-name">${tool.name}</div>
              <div class="tool-card-description">${tool.description}</div>
              <div class="tool-card-power">${tool.powerDesc}</div>
              ${buttonHTML}
            </div>
          `;
        }
      }).join('');
      
      elements.shopGrid.innerHTML = shopHTML;
    }

    function buyTool(toolId) {
      const tool = TOOLS[toolId];
      if (!tool || gameState.coins < tool.cost || gameState.ownedTools.includes(toolId)) {
        playSound('error');
        return;
      }
      
      gameState.coins -= tool.cost;
      gameState.ownedTools.push(toolId);
      
      playSound('coin');
      updateUI();
      renderShopItems();
      
      // Show purchase feedback
      setTimeout(() => {
        alert(`ğŸ‰ æˆåŠŸè´­ä¹° ${tool.name}ï¼`);
      }, 100);
    }

    function equipTool(toolId) {
      if (!TOOLS[toolId] || !gameState.ownedTools.includes(toolId)) {
        playSound('error');
        return;
      }
      
      gameState.equippedTool = toolId;
      playSound('success');
      updateUI();
      renderShopItems();
    }

    // Inventory Functions
    function openInventory() {
      elements.inventoryModal.style.display = 'flex';
      renderInventory();
    }

    function closeInventory() {
      elements.inventoryModal.style.display = 'none';
    }

    function renderInventory() {
      if (gameState.inventory.length === 0) {
        elements.inventoryGrid.innerHTML = `
          <div class="empty-inventory">
            <span class="empty-inventory-icon">ğŸ“¦</span>
            <h3>èƒŒåŒ…ç©ºç©ºå¦‚ä¹Ÿ</h3>
            <p>å»æŒ–æ˜ä¸€äº›å®ç‰©å§ï¼</p>
          </div>
        `;
        return;
      }

      const inventoryHTML = gameState.inventory.map((treasure, index) => `
        <div class="treasure-item">
          <span class="treasure-item-icon">${treasure.icon}</span>
          <div class="treasure-item-name">${treasure.name}</div>
          <div class="treasure-item-desc">${treasure.desc}</div>
          <div class="treasure-item-value">ä»·å€¼: ${treasure.value} é‡‘å¸</div>
        </div>
      `).join('');
      
      elements.inventoryGrid.innerHTML = inventoryHTML;
    }

    // Market Functions
    function openMarket() {
      elements.marketModal.style.display = 'flex';
      elements.marketCoins.textContent = gameState.coins;
      renderMarket();
    }

    function closeMarket() {
      elements.marketModal.style.display = 'none';
    }

    function renderMarket() {
      if (gameState.inventory.length === 0) {
        elements.marketGrid.innerHTML = `
          <div class="empty-market">
            <span class="empty-market-icon">ğŸª</span>
            <h3>æ²¡æœ‰å¯å‡ºå”®çš„å®ç‰©</h3>
            <p>å…ˆå»æŒ–æ˜ä¸€äº›å®ç‰©ï¼Œç„¶åå›æ¥å‡ºå”®å§ï¼</p>
          </div>
        `;
        return;
      }

      const marketHTML = gameState.inventory.map((treasure, index) => {
        // Calculate market price with some fluctuation (80%-120% of base value)
        const fluctuation = 0.8 + Math.random() * 0.4; // 0.8 to 1.2
        const marketPrice = Math.floor(treasure.value * fluctuation);
        
        // Show potential bonus if market insider is owned
        let bonusText = '';
        if (gameState.auxiliaryTools.includes('market_insider')) {
          bonusText = ' ğŸ“ˆ (å†…å¹•åŠ æˆ)';
        }
        
        return `
          <div class="treasure-item">
            <span class="treasure-item-icon">${treasure.icon}</span>
            <div class="treasure-item-name">${treasure.name}</div>
            <div class="treasure-item-desc">${treasure.desc}</div>
            <div class="treasure-item-value">å¸‚åœºä»·: ${marketPrice} é‡‘å¸${bonusText}</div>
            <button class="sell-btn" onclick="enhancedSellTreasure(${index}, ${marketPrice})">
              ğŸ’° å‡ºå”® ${marketPrice}é‡‘å¸
            </button>
          </div>
        `;
      }).join('');
      
      elements.marketGrid.innerHTML = marketHTML;
    }

    function sellTreasure(index, price) {
      if (index < 0 || index >= gameState.inventory.length) {
        playSound('error');
        return;
      }
      
      const treasure = gameState.inventory[index];
      gameState.coins += price;
      gameState.inventory.splice(index, 1);
      
      playSound('coin');
      updateUI();
      renderMarket();
      
      // Show sell feedback
      setTimeout(() => {
        alert(`ğŸ’° æˆåŠŸå‡ºå”® ${treasure.name}ï¼è·å¾— ${price} é‡‘å¸`);
      }, 100);
    }

    // Auxiliary tool functions
    function buyAuxiliaryTool(toolId) {
      const tool = TOOLS[toolId];
      if (!tool || gameState.coins < tool.cost || gameState.auxiliaryTools.includes(toolId)) {
        playSound('error');
        return;
      }
      
      gameState.coins -= tool.cost;
      gameState.auxiliaryTools.push(toolId);
      
      playSound('coin');
      updateUI();
      renderShopItems();
      
      setTimeout(() => {
        alert(`ğŸ‰ æˆåŠŸè´­ä¹°è¾…åŠ©å·¥å…· ${tool.name}ï¼`);
      }, 100);
    }

    function buyConsumable(toolId) {
      const tool = TOOLS[toolId];
      if (!tool || gameState.coins < tool.cost) {
        playSound('error');
        return;
      }
      
      gameState.coins -= tool.cost;
      if (!gameState.consumableItems[toolId]) {
        gameState.consumableItems[toolId] = 0;
      }
      gameState.consumableItems[toolId]++;
      
      playSound('coin');
      updateUI();
      renderShopItems();
      
      setTimeout(() => {
        alert(`âš¡ æˆåŠŸè´­ä¹° ${tool.name}ï¼ç°åœ¨æ‹¥æœ‰ ${gameState.consumableItems[toolId]} ä¸ª`);
      }, 100);
    }

    // Enhanced treasure creation with auxiliary effects and card effects
    function enhancedCreateTreasureSpot(id, maxWidth, maxHeight) {
      let words = getAllWords();
      let rarityBoost = false;
      
      // Lucky charm auxiliary tool effect
      if (gameState.auxiliaryTools.includes('lucky_charm')) {
        rarityBoost = Math.random() < 0.25; // 25% chance
      }
      
      // Luck boost card effect
      const luckEffect = gameState.activeEffects.find(e => e.type === 'luck_boost');
      if (luckEffect) {
        rarityBoost = rarityBoost || Math.random() < 0.40; // 40% chance with card
      }
      
      if (rarityBoost) {
        // Filter to higher value words
        words = words.filter(w => w.value >= 100);
        if (words.length === 0) words = getAllWords();
      }
      
      const word = words[Math.floor(Math.random() * words.length)];
      
      // Determine treasure type based on word value
      let type = 'bronze';
      if (word.value >= 300) type = 'diamond';
      else if (word.value >= 150) type = 'gold';
      else if (word.value >= 60) type = 'silver';
      
      const treasureConfig = TREASURE_VALUES[type];
      const hitsRequired = treasureConfig.hits[Math.floor(Math.random() * treasureConfig.hits.length)];
      
      return {
        id,
        word,
        type,
        value: word.value,
        hitsRequired,
        hitsRemaining: hitsRequired,
        x: Math.random() * (maxWidth - 60),
        y: Math.random() * (maxHeight - 60),
        discovered: false,
        showValue: gameState.auxiliaryTools.includes('treasure_detector')
      };
    }

    // Enhanced sell function with market insider effect
    function enhancedSellTreasure(index, basePrice) {
      if (index < 0 || index >= gameState.inventory.length) {
        playSound('error');
        return;
      }
      
      const treasure = gameState.inventory[index];
      let finalPrice = basePrice;
      
      // Market insider effect - 10-30% bonus
      if (gameState.auxiliaryTools.includes('market_insider')) {
        const bonus = 1.1 + Math.random() * 0.2; // 1.1 to 1.3 multiplier
        finalPrice = Math.floor(basePrice * bonus);
      }
      
      gameState.coins += finalPrice;
      gameState.inventory.splice(index, 1);
      
      playSound('coin');
      updateUI();
      renderMarket();
      
      const bonusText = finalPrice > basePrice ? ` (å†…å¹•åŠ æˆ!)` : '';
      setTimeout(() => {
        alert(`ğŸ’° æˆåŠŸå‡ºå”® ${treasure.name}ï¼è·å¾— ${finalPrice} é‡‘å¸${bonusText}`);
      }, 100);
    }

    // Use energy drink function
    function useEnergyDrink() {
      if (gameState.consumableItems['energy_drink'] > 0) {
        gameState.consumableItems['energy_drink']--;
        gameState.activeEffects.push({
          type: 'energy_boost',
          remaining: 1 // Next dig gets +1 power
        });
        
        playSound('magic');
        alert('âš¡ ä½¿ç”¨èƒ½é‡é¥®æ–™ï¼ä¸‹æ¬¡æŒ–æ˜å¨åŠ›+1ï¼');
        updateUI();
        renderShopItems();
      } else {
        playSound('error');
        alert('âš¡ æ²¡æœ‰èƒ½é‡é¥®æ–™äº†ï¼åˆ°å•†åº—è´­ä¹°å§ï¼');
      }
    }

    // Skill Cards Functions
    function openCards() {
      elements.cardsModal.style.display = 'flex';
      elements.cardsCoins.textContent = gameState.coins;
      renderSkillCards();
    }

    function closeCards() {
      elements.cardsModal.style.display = 'none';
    }

    function renderSkillCards() {
      renderEquippedCards();
      renderAvailableCards();
    }

    function renderEquippedCards() {
      const equippedHTML = [];
      
      for (let i = 0; i < 3; i++) {
        const equippedCard = gameState.equippedCards[i];
        if (equippedCard) {
          const card = SKILL_CARDS[equippedCard];
          const cooldown = gameState.cardCooldowns[equippedCard] || 0;
          const canUse = cooldown === 0;
          
          equippedHTML.push(`
            <div class="skill-card equipped ${card.rarity}" style="position: relative;">
              <span class="skill-card-icon">${card.icon}</span>
              <div class="skill-card-name">${card.name}</div>
              <div class="skill-card-description">${card.description}</div>
              <div class="skill-card-cooldown">å†·å´: ${card.cooldown}å›åˆ</div>
              ${cooldown > 0 ? `<div class="cooldown-overlay">${cooldown}</div>` : ''}
              <button class="skill-card-btn ${canUse ? 'use' : 'on-cooldown'}" ${!canUse ? 'disabled' : ''} onclick="useSkillCard('${card.id}')">
                ${canUse ? 'ä½¿ç”¨' : `å†·å´ä¸­(${cooldown})`}
              </button>
              <button class="skill-card-btn unequip" onclick="unequipCard(${i})" style="margin-top: 5px;">å¸ä¸‹</button>
            </div>
          `);
        } else {
          equippedHTML.push(`
            <div class="empty-slot">
              <div style="color: rgba(255,255,255,0.5); font-size: 12px;">
                ç©ºå¡æ§½<br>
                <span style="font-size: 20px;">â¬œ</span>
              </div>
            </div>
          `);
        }
      }
      
      elements.equippedCardsGrid.innerHTML = equippedHTML.join('');
    }

    function renderAvailableCards() {
      const cardsHTML = Object.entries(SKILL_CARDS).map(([cardId, card]) => {
        const isOwned = gameState.skillCards.includes(cardId);
        const isEquipped = gameState.equippedCards.includes(cardId);
        const canAfford = gameState.coins >= card.cost;
        const rarity = CARD_RARITY[card.rarity];
        
        let cardClass = `skill-card ${card.rarity}`;
        if (isOwned) cardClass += ' owned';
        if (isEquipped) cardClass += ' equipped';
        
        let buttonHTML = '';
        if (!isOwned) {
          buttonHTML = `
            <div class="skill-card-price">ğŸ’° ${card.cost} é‡‘å¸</div>
            <button class="skill-card-btn" ${!canAfford ? 'disabled' : ''} onclick="buySkillCard('${cardId}')">
              ${canAfford ? 'è´­ä¹°' : 'é‡‘å¸ä¸è¶³'}
            </button>
          `;
        } else if (!isEquipped && gameState.equippedCards.length < 3) {
          buttonHTML = `
            <div class="skill-card-price">âœ… å·²æ‹¥æœ‰</div>
            <button class="skill-card-btn equip" onclick="equipCard('${cardId}')">è£…å¤‡</button>
          `;
        } else if (!isEquipped) {
          buttonHTML = `
            <div class="skill-card-price">âœ… å·²æ‹¥æœ‰</div>
            <button class="skill-card-btn" disabled>å¡æ§½å·²æ»¡</button>
          `;
        } else {
          buttonHTML = `
            <div class="skill-card-price">âœ… å·²è£…å¤‡</div>
            <button class="skill-card-btn unequip" onclick="unequipCardById('${cardId}')">å¸ä¸‹</button>
          `;
        }
        
        return `
          <div class="${cardClass}">
            <span class="skill-card-icon">${card.icon}</span>
            <div class="skill-card-name">${card.name}</div>
            <div class="skill-card-description">${card.description}</div>
            <div class="skill-card-cooldown">å†·å´: ${card.cooldown}å›åˆ</div>
            ${buttonHTML}
          </div>
        `;
      }).join('');
      
      elements.cardsGrid.innerHTML = cardsHTML;
    }

    function buySkillCard(cardId) {
      const card = SKILL_CARDS[cardId];
      if (!card || gameState.coins < card.cost || gameState.skillCards.includes(cardId)) {
        playSound('error');
        return;
      }
      
      gameState.coins -= card.cost;
      gameState.skillCards.push(cardId);
      
      playSound('coin');
      updateUI();
      renderSkillCards();
      
      setTimeout(() => {
        alert(`ğŸ‰ æˆåŠŸè·å¾—æŠ€èƒ½å¡ç‰Œ ${card.name}ï¼`);
      }, 100);
    }

    function equipCard(cardId) {
      if (gameState.equippedCards.length >= 3 || gameState.equippedCards.includes(cardId) || !gameState.skillCards.includes(cardId)) {
        playSound('error');
        return;
      }
      
      gameState.equippedCards.push(cardId);
      playSound('success');
      renderSkillCards();
    }

    function unequipCard(slotIndex) {
      if (slotIndex >= 0 && slotIndex < gameState.equippedCards.length) {
        gameState.equippedCards.splice(slotIndex, 1);
        playSound('click');
        renderSkillCards();
      }
    }

    function unequipCardById(cardId) {
      const index = gameState.equippedCards.indexOf(cardId);
      if (index !== -1) {
        gameState.equippedCards.splice(index, 1);
        playSound('click');
        renderSkillCards();
      }
    }

    function useSkillCard(cardId) {
      const card = SKILL_CARDS[cardId];
      if (!card || !gameState.equippedCards.includes(cardId)) {
        playSound('error');
        return;
      }
      
      // Check cooldown
      const cooldown = gameState.cardCooldowns[cardId] || 0;
      if (cooldown > 0) {
        playSound('error');
        alert(`æŠ€èƒ½è¿˜åœ¨å†·å´ä¸­ï¼Œå‰©ä½™ ${cooldown} å›åˆ`);
        return;
      }
      
      // Apply card effect
      applyCardEffect(card);
      
      // Set cooldown
      gameState.cardCooldowns[cardId] = card.cooldown;
      
      playSound('magic');
      updateUI();
      renderSkillCards();
    }

    function applyCardEffect(card) {
      const effect = card.effect;
      
      switch(effect.type) {
        case 'next_dig_power':
          gameState.activeEffects.push({
            type: 'power_boost',
            multiplier: effect.multiplier,
            remaining: 1
          });
          alert(`ğŸ’ª ${card.name} å·²æ¿€æ´»ï¼ä¸‹æ¬¡æŒ–æ˜åŠ›é‡ç¿»å€ï¼`);
          break;
          
        case 'instant_complete':
          // Complete current treasure instantly if any
          const activeTreasures = gameState.treasureSpots.filter(spot => !spot.discovered && spot.hitsRemaining < spot.hitsRequired);
          if (activeTreasures.length > 0) {
            const targetSpot = activeTreasures[0];
            targetSpot.hitsRemaining = 0;
            targetSpot.discovered = true;
            playSound('treasure_found');
            setTimeout(() => showLearningModal(targetSpot), 500);
            alert(`âš¡ ${card.name} å·²æ¿€æ´»ï¼ç¬é—´å®Œæˆäº†ä¸€ä¸ªå®ç‰©çš„æŒ–æ˜ï¼`);
          } else {
            alert(`âš¡ ${card.name} å·²æ¿€æ´»ï¼Œä½†æ²¡æœ‰æ­£åœ¨æŒ–æ˜çš„å®ç‰©ã€‚`);
          }
          break;
          
        case 'spawn_treasure':
          // Add a new treasure to empty spot
          const maxSpots = gameState.treasureSpots.length + 5;
          if (gameState.treasureSpots.filter(spot => !spot.discovered).length < maxSpots) {
            const newSpot = enhancedCreateTreasureSpot(gameState.treasureSpots.length, 500, 500);
            gameState.treasureSpots.push(newSpot);
            
            // Create visual element
            const spotElement = document.createElement('div');
            spotElement.className = `treasure-spot treasure-${newSpot.type}`;
            spotElement.style.left = newSpot.x + 'px';
            spotElement.style.top = newSpot.y + 'px';
            spotElement.dataset.spotId = newSpot.id;
            
            const buriedDiv = document.createElement('div');
            buriedDiv.className = 'treasure-buried';
            buriedDiv.textContent = newSpot.word.icon;
            spotElement.appendChild(buriedDiv);
            
            elements.dirtArea.appendChild(spotElement);
            spotElement.addEventListener('click', () => digTreasure(newSpot.id));
            
            alert(`ğŸ§² ${card.name} å·²æ¿€æ´»ï¼å¸å¼•äº†ä¸€ä¸ªæ–°å®ç‰©ï¼`);
          }
          break;
          
        case 'gold_boost':
          gameState.activeEffects.push({
            type: 'gold_multiplier',
            multiplier: effect.multiplier,
            remaining: effect.duration
          });
          alert(`âœ¨ ${card.name} å·²æ¿€æ´»ï¼æ¥ä¸‹æ¥${effect.duration}ä¸ªå®ç‰©çš„ä»·å€¼å°†å¢åŠ ${Math.round((effect.multiplier-1)*100)}%ï¼`);
          break;
          
        case 'luck_boost':
          gameState.activeEffects.push({
            type: 'luck_boost',
            remaining: effect.duration
          });
          alert(`ğŸ€ ${card.name} å·²æ¿€æ´»ï¼æ¥ä¸‹æ¥${effect.duration}å›åˆå°†æœ‰æ›´é«˜æ¦‚ç‡å‘ç°ç¨€æœ‰å®ç‰©ï¼`);
          break;
          
        case 'reset_cooldowns':
          // Reset all other card cooldowns
          Object.keys(gameState.cardCooldowns).forEach(cardId => {
            if (cardId !== card.id) {
              gameState.cardCooldowns[cardId] = 0;
            }
          });
          alert(`ğŸ”¥ ${card.name} å·²æ¿€æ´»ï¼æ‰€æœ‰å…¶ä»–æŠ€èƒ½å¡çš„å†·å´æ—¶é—´å·²é‡ç½®ï¼`);
          break;
          
        case 'tool_boost':
          gameState.activeEffects.push({
            type: 'tool_efficiency',
            multiplier: effect.multiplier,
            remaining: effect.duration
          });
          alert(`ğŸ”§ ${card.name} å·²æ¿€æ´»ï¼å·¥å…·æ•ˆç‡æå‡${Math.round((effect.multiplier-1)*100)}%ï¼ŒæŒç»­${effect.duration}æ¬¡æŒ–æ˜ï¼`);
          break;
          
        case 'reveal_treasures':
          // Show all treasure locations temporarily
          gameState.activeEffects.push({
            type: 'treasure_vision',
            remaining: effect.duration
          });
          // Highlight all treasures
          gameState.treasureSpots.forEach((spot, index) => {
            if (!spot.discovered) {
              const spotElement = document.querySelector(`[data-spot-id="${index}"]`);
              if (spotElement) {
                spotElement.style.boxShadow = '0 0 20px #FFD700';
                spotElement.style.border = '3px solid #FFD700';
              }
            }
          });
          alert(`ğŸ‘ï¸ ${card.name} å·²æ¿€æ´»ï¼æ‰€æœ‰å®ç‰©ä½ç½®å·²æ˜¾ç°ï¼ŒæŒç»­${effect.duration}å›åˆï¼`);
          
          // Remove highlight after duration
          setTimeout(() => {
            gameState.treasureSpots.forEach((spot, index) => {
              const spotElement = document.querySelector(`[data-spot-id="${index}"]`);
              if (spotElement) {
                spotElement.style.boxShadow = '';
                spotElement.style.border = '';
              }
            });
          }, effect.duration * 10000); // Assume each "round" is 10 seconds
          break;
          
        default:
          console.log('Unknown card effect:', effect.type);
      }
    }

    // Reduce card cooldowns after each treasure discovery
    function reduceCardCooldowns() {
      Object.keys(gameState.cardCooldowns).forEach(cardId => {
        if (gameState.cardCooldowns[cardId] > 0) {
          gameState.cardCooldowns[cardId]--;
        }
      });
    }

    // Battle System
    function startBattle(enemy) {
      if (gameState.inBattle || enemy.defeated) return;
      
      gameState.inBattle = true;
      gameState.currentEnemy = enemy;
      gameState.battleTurn = 'player';
      
      // Show battle modal
      elements.battleModal.style.display = 'flex';
      
      // Update battle UI
      updateBattleUI();
      
      // Add battle log message
      addBattleLog(`é­é‡äº†${enemy.name}ï¼æˆ˜æ–—å¼€å§‹ï¼`, 'system');
      
      playSound('treasure_found'); // Battle start sound
    }
    
    function updateBattleUI() {
      const player = gameState.player;
      const enemy = gameState.currentEnemy;
      
      if (!enemy) return;
      
      // Update player stats
      elements.battlePlayerStats.textContent = `HP: ${player.hp}/${player.maxHp} | ATK: ${player.attack} | DEF: ${player.defense}`;
      elements.battlePlayerHp.style.width = `${(player.hp / player.maxHp) * 100}%`;
      
      // Update enemy stats
      elements.battleEnemyName.textContent = enemy.name;
      elements.battleEnemyChar.textContent = enemy.icon;
      elements.battleEnemyStats.textContent = `HP: ${enemy.hp}/${enemy.maxHp} | ATK: ${enemy.attack}`;
      elements.battleEnemyHp.style.width = `${(enemy.hp / enemy.maxHp) * 100}%`;
      
      // Enable/disable action buttons based on turn
      const buttons = elements.battleActions.querySelectorAll('.battle-btn');
      buttons.forEach(btn => {
        btn.disabled = gameState.battleTurn !== 'player';
      });
    }
    
    function addBattleLog(message, type = 'normal') {
      const logElement = document.createElement('div');
      logElement.className = `battle-message ${type}`;
      logElement.textContent = message;
      
      elements.battleLog.appendChild(logElement);
      elements.battleLog.scrollTop = elements.battleLog.scrollHeight;
    }
    
    function playerAttack() {
      if (gameState.battleTurn !== 'player' || !gameState.currentEnemy) return;
      
      const player = gameState.player;
      const enemy = gameState.currentEnemy;
      
      // Calculate damage
      let damage = Math.max(1, player.attack - enemy.defense + Math.floor(Math.random() * 5) - 2);
      
      // Apply card effects
      const powerBoost = gameState.activeEffects.find(e => e.type === 'power_boost');
      if (powerBoost) {
        damage *= powerBoost.multiplier;
        powerBoost.remaining--;
        if (powerBoost.remaining <= 0) {
          gameState.activeEffects = gameState.activeEffects.filter(e => e !== powerBoost);
        }
      }
      
      enemy.hp = Math.max(0, enemy.hp - damage);
      
      // Update battle UI
      updateBattleUI();
      
      // Add to battle log
      addBattleLog(`ä½ æ”»å‡»äº†${enemy.name}ï¼Œé€ æˆäº†${damage}ç‚¹ä¼¤å®³ï¼`, 'player-action');
      
      // Check if enemy defeated
      if (enemy.hp <= 0) {
        enemyDefeated();
        return;
      }
      
      // Enemy turn
      gameState.battleTurn = 'enemy';
      setTimeout(enemyAttack, 1000);
    }
    
    function playerDefend() {
      if (gameState.battleTurn !== 'player') return;
      
      // Restore some HP and reduce incoming damage next turn
      const healAmount = Math.floor(gameState.player.maxHp * 0.1);
      gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
      
      // Add defense buff
      gameState.activeEffects.push({
        type: 'defense_boost',
        remaining: 1
      });
      
      addBattleLog(`ä½ è¿›å…¥é˜²å¾¡å§¿æ€ï¼Œæ¢å¤äº†${healAmount}ç‚¹ç”Ÿå‘½ï¼`, 'player-action');
      updateBattleUI();
      
      // Enemy turn
      gameState.battleTurn = 'enemy';
      setTimeout(enemyAttack, 1000);
    }
    
    function useSkillInBattle() {
      if (gameState.battleTurn !== 'player') return;
      
      // Find usable cards
      const usableCards = gameState.equippedCards.filter(cardId => {
        const cooldown = gameState.cardCooldowns[cardId] || 0;
        return cooldown === 0;
      });
      
      if (usableCards.length === 0) {
        addBattleLog('æ²¡æœ‰å¯ç”¨çš„æŠ€èƒ½å¡ï¼', 'system');
        return;
      }
      
      // Use first available card (simplified)
      const cardId = usableCards[0];
      const card = SKILL_CARDS[cardId];
      
      if (card) {
        useSkillCard(cardId);
        addBattleLog(`ä½¿ç”¨äº†æŠ€èƒ½å¡ï¼š${card.name}ï¼`, 'player-action');
        
        // Enemy turn
        gameState.battleTurn = 'enemy';
        setTimeout(enemyAttack, 1000);
      }
    }
    
    function fleeBattle() {
      if (gameState.battleTurn !== 'player') return;
      
      const fleeChance = 0.7; // 70% success rate
      if (Math.random() < fleeChance) {
        addBattleLog('æˆåŠŸé€ƒè·‘äº†ï¼', 'system');
        endBattle(false);
      } else {
        addBattleLog('é€ƒè·‘å¤±è´¥ï¼', 'system');
        // Enemy gets a free attack
        gameState.battleTurn = 'enemy';
        setTimeout(enemyAttack, 500);
      }
    }
    
    function enemyAttack() {
      if (gameState.battleTurn !== 'enemy' || !gameState.currentEnemy) return;
      
      const player = gameState.player;
      const enemy = gameState.currentEnemy;
      
      // Calculate damage
      let damage = Math.max(1, enemy.attack - player.defense + Math.floor(Math.random() * 3) - 1);
      
      // Apply defense boost
      const defenseBoost = gameState.activeEffects.find(e => e.type === 'defense_boost');
      if (defenseBoost) {
        damage = Math.floor(damage * 0.5); // 50% damage reduction
        defenseBoost.remaining--;
        if (defenseBoost.remaining <= 0) {
          gameState.activeEffects = gameState.activeEffects.filter(e => e !== defenseBoost);
        }
      }
      
      player.hp = Math.max(0, player.hp - damage);
      
      // Update battle UI
      updateBattleUI();
      
      // Add to battle log
      addBattleLog(`${enemy.name}æ”»å‡»äº†ä½ ï¼Œé€ æˆäº†${damage}ç‚¹ä¼¤å®³ï¼`, 'enemy-action');
      
      // Check if player defeated
      if (player.hp <= 0) {
        playerDefeated();
        return;
      }
      
      // Player turn
      gameState.battleTurn = 'player';
    }
    
    function enemyDefeated() {
      const enemy = gameState.currentEnemy;
      
      // Mark enemy as defeated
      enemy.defeated = true;
      
      // Remove enemy from visual
      const enemyElement = document.querySelector(`[data-enemy-id="${enemy.id}"]`);
      if (enemyElement) {
        enemyElement.style.animation = 'treasureCollected 0.5s ease-out forwards';
        setTimeout(() => {
          if (enemyElement.parentNode) {
            enemyElement.parentNode.removeChild(enemyElement);
          }
        }, 500);
      }
      
      // Give rewards
      gameState.coins += enemy.gold;
      gameState.player.exp += enemy.exp;
      
      // Check level up
      checkLevelUp();
      
      addBattleLog(`å‡»è´¥äº†${enemy.name}ï¼è·å¾—äº†${enemy.gold}é‡‘å¸å’Œ${enemy.exp}ç»éªŒï¼`, 'system');
      
      // Play victory sound
      playSound('success');
      
      setTimeout(() => {
        endBattle(true);
      }, 2000);
    }
    
    function playerDefeated() {
      // Player loses some gold
      const goldLoss = Math.floor(gameState.coins * 0.1);
      gameState.coins = Math.max(0, gameState.coins - goldLoss);
      
      // Restore player HP
      gameState.player.hp = Math.floor(gameState.player.maxHp * 0.5);
      
      addBattleLog(`ä½ è¢«å‡»è´¥äº†ï¼å¤±å»äº†${goldLoss}é‡‘å¸ã€‚`, 'system');
      
      playSound('error');
      
      setTimeout(() => {
        endBattle(false);
      }, 2000);
    }
    
    function endBattle(victory) {
      gameState.inBattle = false;
      gameState.currentEnemy = null;
      gameState.battleTurn = 'player';
      
      elements.battleModal.style.display = 'none';
      
      // Clear battle log
      elements.battleLog.innerHTML = '';
      
      updateUI();
    }
    
    // Level up system
    function checkLevelUp() {
      const player = gameState.player;
      
      while (player.exp >= player.expToNext) {
        player.exp -= player.expToNext;
        player.level++;
        
        // Increase stats
        player.maxHp += 10;
        player.hp = player.maxHp; // Full heal on level up
        player.attack += 2;
        player.defense += 1;
        player.expToNext = Math.floor(player.expToNext * 1.2);
        
        playSound('level_up');
        alert(`ğŸ‰ ç­‰çº§æå‡ï¼ç°åœ¨æ˜¯${player.level}çº§ï¼\nç”Ÿå‘½å€¼+10ï¼Œæ”»å‡»åŠ›+2ï¼Œé˜²å¾¡åŠ›+1`);
      }
    }

    // Make functions global for onclick handlers
    window.buyTool = buyTool;
    window.equipTool = equipTool;
    window.sellTreasure = sellTreasure;
    window.buyAuxiliaryTool = buyAuxiliaryTool;
    window.buyConsumable = buyConsumable;
    window.enhancedSellTreasure = enhancedSellTreasure;
    window.useEnergyDrink = useEnergyDrink;
    window.useConsumable = useConsumable;
    window.buySkillCard = buySkillCard;
    window.equipCard = equipCard;
    window.unequipCard = unequipCard;
    window.unequipCardById = unequipCardById;
    window.useSkillCard = useSkillCard;
    window.playerAttack = playerAttack;
    window.playerDefend = playerDefend;
    window.useSkillInBattle = useSkillInBattle;
    window.fleeBattle = fleeBattle;

    // Speech Recognition (simplified)
    function setupSpeechRecognition() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) return;
      
      const recognition = new SpeechRecognition();
      recognition.lang = 'en-US';
      recognition.continuous = false;
      
      recognition.onresult = (event) => {
        const said = event.results[0][0].transcript.trim().toLowerCase();
        const target = gameState.currentTreasure?.word.name.toLowerCase();
        
        if (said === target) {
          handleCorrectAnswer();
        } else {
          playSound('error');
          elements.learningFeedback.textContent = `âŒ ä½ è¯´çš„æ˜¯"${said}"ï¼Œæ­£ç¡®çš„æ˜¯"${target}"`;
          elements.learningFeedback.className = 'feedback error';
          
          // Auto-play correct pronunciation after 1 second
          setTimeout(() => {
            if (gameState.currentTreasure) {
              speakWord(gameState.currentTreasure.word.name);
            }
          }, 1000);
        }
      };
      
      elements.speakBtn.addEventListener('click', () => {
        playSound('click');
        if (!gameState.recognizing) {
          gameState.recognizing = true;
          elements.speakBtn.textContent = 'ğŸ™ï¸ å¬ä¸­...';
          recognition.start();
        }
      });
      
      recognition.onend = () => {
        gameState.recognizing = false;
        elements.speakBtn.textContent = 'å¼€å§‹è¯­éŸ³è¯†åˆ«';
      };
    }

    // Text-to-Speech
    function speakWord(word) {
      if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(word);
        utterance.lang = 'en-US';
        utterance.rate = 0.8;
        speechSynthesis.speak(utterance);
      }
    }

    // Keyboard Movement System
    let keysPressed = {};
    const MOVEMENT_SPEED = 3;
    const GAME_BOUNDS = { width: 500, height: 500 };
    
    function setupKeyboardControls() {
      document.addEventListener('keydown', (e) => {
        if (gameState.inBattle) return; // Disable movement during battle
        
        keysPressed[e.key.toLowerCase()] = true;
        
        // Prevent default browser behavior for WASD keys
        if (['w', 'a', 's', 'd'].includes(e.key.toLowerCase())) {
          e.preventDefault();
        }
      });
      
      document.addEventListener('keyup', (e) => {
        keysPressed[e.key.toLowerCase()] = false;
      });
      
      // Movement loop
      setInterval(updatePlayerMovement, 16); // ~60 FPS
    }
    
    function updatePlayerMovement() {
      if (gameState.inBattle) return;
      
      let newX = gameState.player.x;
      let newY = gameState.player.y;
      
      // Handle WASD movement
      if (keysPressed['w'] || keysPressed['arrowup']) {
        newY -= MOVEMENT_SPEED;
      }
      if (keysPressed['s'] || keysPressed['arrowdown']) {
        newY += MOVEMENT_SPEED;
      }
      if (keysPressed['a'] || keysPressed['arrowleft']) {
        newX -= MOVEMENT_SPEED;
      }
      if (keysPressed['d'] || keysPressed['arrowright']) {
        newX += MOVEMENT_SPEED;
      }
      
      // Keep player within bounds
      newX = Math.max(20, Math.min(GAME_BOUNDS.width - 40, newX));
      newY = Math.max(20, Math.min(GAME_BOUNDS.height - 40, newY));
      
      // Update position if changed
      if (newX !== gameState.player.x || newY !== gameState.player.y) {
        gameState.player.x = newX;
        gameState.player.y = newY;
        
        // Update visual position
        if (elements.playerCharacter) {
          elements.playerCharacter.style.left = newX + 'px';
          elements.playerCharacter.style.top = newY + 'px';
        }
        
        // Check for proximity interactions
        checkProximityInteractions();
      }
    }
    
    // Proximity Interaction System
    function checkProximityInteractions() {
      const playerRect = {
        x: gameState.player.x,
        y: gameState.player.y,
        width: 40,
        height: 40
      };
      
      // Check treasure proximity
      gameState.treasureSpots.forEach((spot, index) => {
        if (spot.discovered) return;
        
        const distance = getDistance(
          playerRect.x + 20, playerRect.y + 20,
          spot.x + 25, spot.y + 25
        );
        
        const spotElement = document.querySelector(`[data-spot-id="${index}"]`);
        if (spotElement) {
          if (distance < 60) {
            // Show interaction hint
            spotElement.style.boxShadow = '0 0 15px #FFD700';
            spotElement.style.cursor = 'pointer';
            spotElement.style.transform = 'scale(1.05)';
            
            // Auto-dig on space key or click when close
            if (keysPressed[' '] || keysPressed['space']) {
              digTreasure(index);
            }
          } else {
            // Remove interaction hint
            spotElement.style.boxShadow = '';
            spotElement.style.cursor = 'not-allowed';
            spotElement.style.transform = 'scale(1)';
          }
        }
      });
      
      // Check enemy proximity
      gameState.enemies.forEach((enemy, index) => {
        if (enemy.defeated) return;
        
        const distance = getDistance(
          playerRect.x + 20, playerRect.y + 20,
          enemy.x + 17, enemy.y + 17
        );
        
        const enemyElement = document.querySelector(`[data-enemy-id="${index}"]`);
        if (enemyElement) {
          if (distance < 50) {
            // Show battle hint
            enemyElement.style.boxShadow = '0 0 15px #FF4444';
            enemyElement.style.cursor = 'pointer';
            
            // Auto-battle on space key
            if (keysPressed[' '] || keysPressed['space']) {
              startBattle(enemy);
            }
          } else {
            // Remove battle hint
            enemyElement.style.boxShadow = '';
            enemyElement.style.cursor = 'default';
          }
        }
      });
    }
    
    function getDistance(x1, y1, x2, y2) {
      return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }

    // Setup Event Listeners
    function setupEventListeners() {
      setupSpeechRecognition();
      setupKeyboardControls();
      
      elements.listenBtn.addEventListener('click', () => {
        playSound('click');
        if (gameState.currentTreasure) {
          speakWord(gameState.currentTreasure.word.name);
        }
      });
      
      elements.submitWordBtn.addEventListener('click', () => {
        playSound('click');
        const input = elements.wordInput.value.trim().toLowerCase();
        const target = gameState.currentTreasure?.word.name.toLowerCase();
        
        if (input === target) {
          handleCorrectAnswer();
        } else {
          playSound('error');
          elements.learningFeedback.textContent = `âŒ è¾“å…¥é”™è¯¯ï¼æ­£ç¡®çš„æ˜¯"${target}"`;
          elements.learningFeedback.className = 'feedback error';
          
          // Auto-play correct pronunciation
          setTimeout(() => {
            if (gameState.currentTreasure) {
              speakWord(gameState.currentTreasure.word.name);
            }
          }, 1000);
        }
        elements.wordInput.value = '';
      });
      
      elements.wordInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          elements.submitWordBtn.click();
        }
      });
      
      // Close modal when clicking outside
      elements.learningModal.addEventListener('click', (e) => {
        if (e.target === elements.learningModal) {
          hideLearningModal();
        }
      });
      
      // Shop, inventory, and market buttons
      elements.shopBtn.addEventListener('click', () => {
        playSound('click');
        openShop();
      });
      
      elements.shopClose.addEventListener('click', () => {
        playSound('click');
        closeShop();
      });
      
      // Close shop when clicking outside
      elements.shopModal.addEventListener('click', (e) => {
        if (e.target === elements.shopModal) {
          closeShop();
        }
      });
      
      elements.inventoryBtn.addEventListener('click', () => {
        playSound('click');
        openInventory();
      });
      
      elements.inventoryClose.addEventListener('click', () => {
        playSound('click');
        closeInventory();
      });
      
      // Close inventory when clicking outside
      elements.inventoryModal.addEventListener('click', (e) => {
        if (e.target === elements.inventoryModal) {
          closeInventory();
        }
      });
      
      elements.marketBtn.addEventListener('click', () => {
        playSound('click');
        openMarket();
      });
      
      elements.marketClose.addEventListener('click', () => {
        playSound('click');
        closeMarket();
      });
      
      // Close market when clicking outside
      elements.marketModal.addEventListener('click', (e) => {
        if (e.target === elements.marketModal) {
          closeMarket();
        }
      });
      
      elements.cardsBtn.addEventListener('click', () => {
        playSound('click');
        openCards();
      });
      
      elements.cardsClose.addEventListener('click', () => {
        playSound('click');
        closeCards();
      });
      
      // Close cards when clicking outside
      elements.cardsModal.addEventListener('click', (e) => {
        if (e.target === elements.cardsModal) {
          closeCards();
        }
      });
    }

    // Add treasure collected animation
    const style = document.createElement('style');
    style.textContent = `
      @keyframes treasureCollected {
        0% { transform: scale(1) rotate(0deg); opacity: 1; }
        50% { transform: scale(1.3) rotate(180deg); opacity: 0.7; }
        100% { transform: scale(0) rotate(360deg); opacity: 0; }
      }
    `;
    document.head.appendChild(style);

    // Start the game
    initGame();
  </script>
</body>
</html>